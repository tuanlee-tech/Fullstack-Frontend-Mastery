# Callback, Promise, async/await

<details>
<summary><strong>1. Xử lý bất đồng bộ trong JavaScript (Callback, Promise, Async/Await)</strong></summary>

---

## **1. Khái niệm**

* **Bất đồng bộ (Asynchronous)**: thực hiện các công việc tốn thời gian (request server, đọc/ghi file, truy vấn DB) mà **không làm chặn chương trình chính**.
* Nếu xử lý **đồng bộ**, chương trình sẽ chờ A xong mới chạy B → giảm hiệu năng và trải nghiệm người dùng.
* JavaScript **chạy đơn luồng (single-thread)** nên không dùng đa luồng, mà xử lý bất đồng bộ bằng **callback, promise hoặc async/await**.

---

## **2. Callback**

* Callback là hàm được truyền vào hàm khác để **gọi khi công việc bất đồng bộ hoàn thành**.

```js
function doAsync(url, onSuccess, onError) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.onload = () => onSuccess(xhr.responseText);
  xhr.onerror = () => onError(xhr.statusText);
  xhr.send();
}

// Sử dụng
doAsync(
  "https://something.com",
  (value) => console.log(value),
  (error) => console.error(error)
);
```

* **Vấn đề**: Khi thực hiện nhiều request nối tiếp → callback lồng nhau → **Callback Hell**.

```js
doAsync("url1",
  (v1) => {
    doAsync("url2",
      (v2) => { /* ... */ },
      (e2) => { /* ... */ }
    );
  },
  (e1) => { /* ... */ }
);
```

---

## **3. Promise**

* Promise giúp **tránh callback lồng nhau** và quản lý trạng thái bất đồng bộ dễ dàng hơn.
* Cú pháp:

```js
let promise = new Promise((resolve, reject) => {
  // Code async
  // resolve(value) khi thành công
  // reject(error) khi lỗi
});
```

* Ví dụ chuyển từ callback sang Promise:

```js
function doAsync(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}

// Sử dụng
doAsync("https://something.com")
  .then((value) => console.log(value))
  .catch((error) => console.error(error));

// Nhiều request nối tiếp
doAsync("url1")
  .then((v1) => doAsync("url2"))
  .then((v2) => console.log(v2))
  .catch((err) => console.error(err));
```

---

## **4. Async/Await**

* Async/Await là **cú pháp hiện đại**, làm code bất đồng bộ giống code đồng bộ.
* `async` → khai báo hàm bất đồng bộ.
* `await` → đợi Promise hoàn thành.

```js
async function run() {
  try {
    const response1 = await doAsync("https://something.com");
    const response2 = await doAsync("https://other.com");
    console.log(response1, response2);
  } catch (error) {
    console.error(error);
  }
}

run();
```

* Ưu điểm: cấu trúc **rõ ràng, dễ đọc**, dễ quản lý nhiều request nối tiếp.

---

## **5. Tổng kết**

| Cách xử lý  | Ưu điểm                         | Nhược điểm                 |
| ----------- | ------------------------------- | -------------------------- |
| Callback    | Đơn giản, dễ dùng               | Lồng nhiều → Callback Hell |
| Promise     | Quản lý async tốt, chain dễ đọc | Cần hiểu resolve/reject    |
| Async/Await | Code giống đồng bộ, rõ ràng     | Chỉ dùng được với Promise  |

* **Khuyến nghị hiện nay**: sử dụng **Async/Await**, kết hợp Promise để viết code bất đồng bộ mạch lạc và dễ bảo trì.

</details>
<details>
<summary><strong>2. Kết thúc sớm Promise chaining trong JavaScript</strong></summary>

---

## **1. Vấn đề**

Khi bạn có **chuỗi Promise (Promise chaining)**, đôi khi muốn **dừng sớm** nếu một điều kiện không thỏa, ví dụ:

* Khi đăng ký User: nếu email đã tồn tại → dừng chuỗi Promise, không hash mật khẩu và tạo User nữa.

---

## **2. Ví dụ cơ bản**

```js
const increase = (x) => {
  console.log(x);
  return x + 1;
};

const run = (x) => {
  new Promise((resolve) => resolve(x))
    .then((res) => increase(res))
    .then((res) => increase(res))
    .then((res) => increase(res))
    .catch((err) => console.log("Catched: " + err));
};

run(4);
/*
 * Output:
 * 4
 * 5
 * 6
 */
```

* Ở đây, tất cả các `then` đều được thực hiện.
* Vấn đề: muốn **dừng chuỗi nếu res > 3**.

---

## **3. Cách 1: Không return giá trị**

* Nếu `then` **không return** gì, giá trị `undefined` sẽ được truyền sang then tiếp theo.
* Kết quả:

```js
new Promise((resolve) => resolve(x))
  .then((res) => {
    if (res <= 3) return increase(res);
    // else không return gì → res = undefined cho then tiếp theo
  })
  .then((res) => {
    if (res !== undefined) return increase(res);
  })
  .catch((err) => console.log("Catched: " + err));
```

* Ưu điểm: đơn giản.
* Nhược điểm: **chuỗi Promise vẫn tiếp tục chạy**, chỉ là `res = undefined` → dễ gây bug nếu không cẩn thận.

---

## **4. Cách 2: Dùng `Promise.reject()` → Dừng hoàn toàn**

* Khi muốn **thoát khỏi chuỗi Promise** ngay lập tức và nhảy thẳng vào `catch`:

```js
const increase = (x) => {
  console.log(x);
  return x + 1;
};

const run = (x) => {
  new Promise((resolve) => resolve(x))
    .then((res) => {
      if (res <= 3) return increase(res);
      return Promise.reject(res); // Dừng chuỗi, nhảy thẳng catch
    })
    .then((res) => increase(res))
    .then((res) => increase(res))
    .catch((err) => console.log("Catched: " + err));
};

run(3);
/*
 * Output:
 * 3
 * 4
 * 5
 */

run(4);
// Output: Catched: 4
```

* Khi `x = 4` → `Promise.reject(res)` → **bỏ qua tất cả then tiếp theo**, nhảy vào `catch`.
* Đây là cách **an toàn và rõ ràng nhất** để kết thúc sớm Promise chaining.

---

## **5. Kết luận**

| Phương pháp        | Ưu điểm                 | Nhược điểm                     |
| ------------------ | ----------------------- | ------------------------------ |
| Không return       | Đơn giản, nhanh         | Chuỗi Promise vẫn chạy, dễ bug |
| `Promise.reject()` | Dừng hoàn toàn, rõ ràng | Cần có catch xử lý lỗi         |

> ✅ **Khuyến nghị:** Dùng `Promise.reject()` nếu muốn kết thúc sớm chuỗi Promise, đảm bảo không thực hiện các `then` tiếp theo.

</details>
<details>
<summary><strong>3. Bất đồng bộ song song hay tuần tự?</strong></summary>

---

## **1. Bài toán**

Giả sử có một công việc bất đồng bộ `getPost` gồm 3 hành động:

* `getContent()` → Lấy nội dung bài viết (1s)
* `getComments()` → Lấy bình luận (1.5s)
* `getRelatedPosts()` → Lấy bài viết liên quan (2s)

```js
const wait = (ms) => new Promise((res) => setTimeout(res, ms));

const getContent = async () => { await wait(1000); return "This is content"; };
const getComments = async () => { await wait(1500); return ["comment 1", "comment 2"]; };
const getRelatedPosts = async () => { await wait(2000); return ["post 2", "post 3", "post 4"]; };
```

---

## **2. Xử lý tuần tự (Sequential)**

* Các hành động thực hiện **lần lượt**, hành động sau phải đợi hành động trước kết thúc.
* Cú pháp với `async/await`:

```js
const getPostSequential = async () => {
  console.time("Sequential");

  const content = await getContent();
  const comments = await getComments();
  const relatedPosts = await getRelatedPosts();

  console.log({ content, comments, relatedPosts });
  console.timeEnd("Sequential");
};

getPostSequential();
// Output time ~ 4500ms (1000 + 1500 + 2000)
```

* **Ưu điểm:** đơn giản, dễ đọc khi các hành động phụ thuộc lẫn nhau.
* **Nhược điểm:** tốn thời gian, không tối ưu nếu các hành động độc lập.

---

## **3. Xử lý song song (Parallel)**

* Các hành động **khởi chạy cùng lúc**, đợi kết quả **cùng lúc**.
* Cú pháp sử dụng `Promise.all`:

```js
const getPostParallel = async () => {
  console.time("Parallel");

  const [content, comments, relatedPosts] = await Promise.all([
    getContent(),
    getComments(),
    getRelatedPosts()
  ]);

  console.log({ content, comments, relatedPosts });
  console.timeEnd("Parallel");
};

getPostParallel();
// Output time ~ 2000ms (max(1000, 1500, 2000))
```

* **Ưu điểm:** tối ưu thời gian khi các hành động **không phụ thuộc nhau**.
* **Nhược điểm:** nếu một promise lỗi → toàn bộ `Promise.all` bị reject.

---

## **4. Lựa chọn cách xử lý**

| Trường hợp                               | Nên dùng             | Lý do                                 |
| ---------------------------------------- | -------------------- | ------------------------------------- |
| Các hành động **phụ thuộc** kết quả nhau | Tuần tự (Sequential) | Tránh lỗi logic, kết quả đúng thứ tự  |
| Các hành động **độc lập**                | Song song (Parallel) | Tiết kiệm thời gian, tối ưu hiệu năng |

> Ngoài `Promise.all`, bạn có thể sử dụng:
>
> * `Promise.allSettled` → chờ tất cả hoàn thành, không bị reject toàn bộ nếu có lỗi.
> * `Promise.race` → chỉ lấy kết quả promise đầu tiên hoàn thành.
> * `Promise.any` → lấy kết quả **fulfilled** đầu tiên.

---

### **5. Kết luận**

* **Sequential** → đơn giản, an toàn khi phụ thuộc lẫn nhau.
* **Parallel (Promise.all)** → nhanh, tối ưu khi các promise độc lập.

> Mẹo: Luôn cân nhắc **tính phụ thuộc và khả năng lỗi** trước khi chọn cách xử lý bất đồng bộ.

</details>
