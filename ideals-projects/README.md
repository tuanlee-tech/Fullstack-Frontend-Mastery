<h1 align="center">🚀 Real-World App Ideas — Build Useful, Not Just Beautiful Code</h1>

<p align="center">
  <em>Practical, MVP-driven projects for learning & solving real-life problems</em><br/>
  <strong>by Tuan Lee</strong>
</p>

<p align="center">
  <img src="https://img.shields.io/badge/Focus-MVP-blueviolet?style=for-the-badge" />
  <img src="https://img.shields.io/badge/Stack-Fullstack%20JS-orange?style=for-the-badge" />
  <img src="https://img.shields.io/badge/Approach-Problem%20Solving-success?style=for-the-badge" />
</p>

---

## 📘 Table of Contents
- [📘 Table of Contents](#-table-of-contents)
- [🧭 Philosophy](#-philosophy)
- [💡 Project List](#-project-list)
  - [1. Smart Meal Planner](#1-smart-meal-planner)
  - [2. Split Bill \& Expense Tracker](#2-split-bill--expense-tracker)
  - [3. Habit + Accountability Tracker](#3-habit--accountability-tracker)
  - [4. Local Business Booster](#4-local-business-booster)
  - [5. Event Helper](#5-event-helper)
  - [6. Crypto Investment Tracker](#6-crypto-investment-tracker)
  - [7. Freelance Task \& Payment Manager](#7-freelance-task--payment-manager)
  - [8. Insurance / Finance Assistant](#8-insurance--finance-assistant)
  - [9. Money Tracker App](#9-money-tracker-app)
  - [10. AI Study Assistant](#10-ai-study-assistant)
- [🧱 MVP Development Principles](#-mvp-development-principles)
- [🧩 Future Ideas](#-future-ideas)
- [🧑‍💻 Conclusion](#-conclusion)
- [📊 Phân tích 10 Ý tưởng theo Độ khó Tăng dần](#-phân-tích-10-ý-tưởng-theo-độ-khó-tăng-dần)
- [🎯 Tiêu chí đánh giá](#-tiêu-chí-đánh-giá)
- [🟢 LEVEL 1-3: BEGINNER-FRIENDLY (Dễ)](#-level-1-3-beginner-friendly-dễ)
  - [**#1 - Event Helper**](#1---event-helper)
  - [**#2 - Habit + Accountability Tracker**](#2---habit--accountability-tracker)
  - [**#3 - Split Bill \& Tracking**](#3---split-bill--tracking)
- [🟡 LEVEL 4-6: INTERMEDIATE (Trung bình)](#-level-4-6-intermediate-trung-bình)
  - [**#4 - Money Tracker App**](#4---money-tracker-app)
  - [**#5 - Smart Meal Planner**](#5---smart-meal-planner)
  - [**#6 - Insurance/Finance Assistant**](#6---insurancefinance-assistant)
- [🔴 LEVEL 7-8: ADVANCED (Khó)](#-level-7-8-advanced-khó)
  - [**#7 - Local Business Booster**](#7---local-business-booster)
  - [**#8 - Crypto Investment Tracker**](#8---crypto-investment-tracker)
  - [**#9 - Freelance Task \& Payment Manager**](#9---freelance-task--payment-manager)
- [🔥 LEVEL 9-10: EXPERT (Rất khó)](#-level-9-10-expert-rất-khó)
  - [**#10 - AI Study Assistant**](#10---ai-study-assistant)
- [📊 Bảng Tổng Kết](#-bảng-tổng-kết)

---

## 🧭 Philosophy
> Build **useful MVPs** — small but working products that actually help people.  
> Each project should be deployable, not just a “demo for show”.  
> Focus on solving *one real problem* before adding features.

---

## 💡 Project List

### 1. Smart Meal Planner
Gợi ý thực đơn hằng ngày dựa trên **ngân sách & calo mong muốn**.  
Lưu nguyên liệu sẵn có → đề xuất món ăn phù hợp.

🧩 **Skills:**  
AI recommendation, Nutrition API, Local storage, Responsive UI (React/Next.js)

🎯 **Use case:**  
Tiết kiệm thời gian nấu ăn, giúp ăn uống khoa học.

---

### 2. Split Bill & Expense Tracker
Ứng dụng chia tiền **ăn uống / du lịch chung**.  
Mỗi người nhập chi tiêu → app tự tính **ai nợ ai**.

🧩 **Skills:**  
Firebase / WebSocket, Group logic, Expense reports, Shareable links

🎯 **Use case:**  
Chấm dứt cảnh “ai trả hộ ai” – tự động, minh bạch.

---

### 3. Habit + Accountability Tracker
Theo dõi **thói quen cá nhân** (uống nước, đọc sách, tập gym...)  
Người dùng có thể **nhắc nhau** cùng làm — vừa health-tech vừa social.

🧩 **Skills:**  
Push notifications, Habit analytics, Friend reminder system, Gamification

🎯 **Use case:**  
Tạo động lực qua trách nhiệm xã hội và cộng đồng.

---

### 4. Local Business Booster
Web mini giúp **quán nhỏ / shop / cafe** quản lý menu, đơn hàng,  
khách **quét QR để đặt món**.

🧩 **Skills:**  
CRUD menu/orders, QR generator, Dashboard UI, Mobile-first layout

🎯 **Use case:**  
Giúp tiệm nhỏ “chuyển đổi số” dễ dàng.

---

### 5. Event Helper
Tạo và quản lý **sự kiện nhóm nhỏ**: sinh nhật, họp nhóm, meetup,...  
Có RSVP, checklist, chia việc.

🧩 **Skills:**  
Event CRUD, Real-time collaboration, Email/SMS RSVP, Checklist UI

🎯 **Use case:**  
Tổ chức sự kiện nhanh, gọn, không bỏ sót việc.

---

### 6. Crypto Investment Tracker
Lưu portfolio crypto, cập nhật giá **live từ CoinGecko API**,  
tính lãi/lỗ, thống kê chi tiết.

🧩 **Skills:**  
REST/WebSocket API, Auth & portfolio, Charts & caching, Security

🎯 **Use case:**  
Thay thế Excel, theo dõi danh mục đầu tư dễ dàng.

---

### 7. Freelance Task & Payment Manager
Kết nối **freelancer – client**, quản lý task, tiến độ, thanh toán minh bạch.

🧩 **Skills:**  
Auth & roles, Stripe/PayPal integration, Kanban board (Trello), Realtime updates

🎯 **Use case:**  
Quản lý công việc và tiền bạc hiệu quả, chuyên nghiệp.

---

### 8. Insurance / Finance Assistant
Quản lý **bảo hiểm, khoản vay**, theo dõi hạn thanh toán,  
tự động nhắc qua email/sms.

🧩 **Skills:**  
Complex CRUD, Scheduler, Notification system, Data visualization

🎯 **Use case:**  
Không còn quên hạn, dễ theo dõi tình hình tài chính.

---

### 9. Money Tracker App
Theo dõi **thu nhập – chi tiêu**, hiển thị biểu đồ ngày/tháng/năm.

🧩 **Skills:**  
CRUD API (Node.js / NestJS), Auth (JWT/OAuth), Charts (Recharts)

🎯 **Use case:**  
Hiểu rõ thói quen chi tiêu, kiểm soát tài chính cá nhân.

---

### 10. AI Study Assistant
Nhập chủ đề học → AI tự tạo **flashcards, quiz, lộ trình ôn tập** theo spaced repetition.

🧩 **Skills:**  
AI API integration (OpenAI, Gemini,...), Backend (Express/Nest), DB + Spaced repetition

🎯 **Use case:**  
Tăng hiệu quả học và ghi nhớ, học tập thông minh hơn.

---

## 🧱 MVP Development Principles

| Giai đoạn | Mục tiêu | Kết quả |
|------------|-----------|----------|
| **1️⃣ MVP** | Làm ra phiên bản nhỏ nhất có giá trị thật | App có thể chạy, demo được |
| **2️⃣ Iterate** | Thêm từng tính năng nhỏ | Không phá vỡ core logic |
| **3️⃣ Test & Improve** | Kiểm tra hiệu năng, UX | App mượt, dễ dùng |
| **4️⃣ Launch** | Public demo & nhận feedback | Học được từ người dùng thật |

> 💬 Ví dụ:  
> `Money Tracker` có thể bắt đầu chỉ với **một ô input + nút Submit** →  
> rồi dần trở thành app tài chính có **AI nhập liệu, biểu đồ, gợi ý tiết kiệm**.

---

## 🧩 Future Ideas
- 🧑‍🍳 **Cooking Community Platform:** chia sẻ món ăn, nguyên liệu, review cửa hàng.  
- 🧘 **Mindful Tracker:** theo dõi tâm trạng, gợi ý thiền và nghỉ ngơi.  
- 🎯 **Goal Tracker with AI Coach:** AI phản hồi hành vi, nhắc hoàn thành mục tiêu.

---

## 🧑‍💻 Conclusion
Tất cả dự án trong repo này đều:
- ✅ Có thể triển khai thật (Frontend + Backend)
- 🧠 Giúp học toàn diện Fullstack, DevOps, AI
- 🌍 Giải quyết vấn đề thật — không chỉ là “bài tập code”

> ⚙️ *Build things people actually use — not just things that look good.*

---

<p align="center">
  <strong>⭐ Star this repo if you love practical coding!</strong><br/>
  <em>Made with passion by Tuan Lee 💻</em>
</p>

---

## 📊 Phân tích 10 Ý tưởng theo Độ khó Tăng dần

## 🎯 Tiêu chí đánh giá

Mỗi project được đánh giá theo thang điểm 1-10 dựa trên:
- **Frontend Complexity**: UI/UX, state management, real-time
- **Backend Complexity**: API design, database, business logic
- **Integration Complexity**: Third-party services, payments, AI
- **Algorithm Complexity**: Tính toán, recommendation, optimization
- **DevOps & Scale**: Deployment, caching, performance

---

## 🟢 LEVEL 1-3: BEGINNER-FRIENDLY (Dễ)

### **#1 - Event Helper** 
**Điểm tổng: 2.5/10**

```
Frontend Complexity:    ⭐⭐☆☆☆ (2/5)
Backend Complexity:     ⭐⭐☆☆☆ (2/5)
Integration:            ⭐☆☆☆☆ (1/5)
Algorithm:              ⭐☆☆☆☆ (1/5)
DevOps:                 ⭐⭐☆☆☆ (2/5)
───────────────────────────────────
TOTAL:                  2.5/10
```

**Tại sao dễ nhất:**
- ✅ CRUD đơn giản (Event, Guest, Checklist)
- ✅ No payment, no real-time critical
- ✅ UI straightforward (forms, lists, calendar)
- ✅ No complex calculation
- ✅ Can use simple email for RSVP

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js + Zustand + shadcn/ui
Backend: Next.js API Routes + Prisma
Database: PostgreSQL
Email: Resend/SendGrid
Deploy: Vercel
```

**MVP (1 tuần):**
- Tạo event (tên, ngày, địa điểm)
- Thêm guest list
- Simple checklist
- RSVP form

**Challenges nhỏ:**
- Calendar integration (Google Calendar API)
- Email templates
- Guest tracking

---

### **#2 - Habit + Accountability Tracker**
**Điểm tổng: 3/10**

```
Frontend Complexity:    ⭐⭐⭐☆☆ (3/5)
Backend Complexity:     ⭐⭐☆☆☆ (2/5)
Integration:            ⭐⭐☆☆☆ (2/5)
Algorithm:              ⭐⭐☆☆☆ (2/5)
DevOps:                 ⭐⭐☆☆☆ (2/5)
───────────────────────────────────
TOTAL:                  3/10
```

**Tại sao dễ:**
- ✅ Simple data model (Habit, Log)
- ✅ Basic charts (streak, completion rate)
- ✅ Social feature đơn giản (follow friends)
- ✅ Push notification straightforward

**Điểm phức tạp hơn Event Helper:**
- ⚠️ Streak calculation algorithm
- ⚠️ Push notifications (daily reminders)
- ⚠️ Social features (friends, accountability partners)
- ⚠️ Data visualization (habit trends)

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js + Jotai + TailwindCSS
Backend: Next.js + Prisma
Database: PostgreSQL
Notifications: Firebase Cloud Messaging
Real-time: Firebase Realtime Database (cho social)
Deploy: Vercel
```

**MVP (1.5 tuần):**
- Add habit (name, frequency)
- Daily check-in (mark complete)
- Streak counter
- Simple calendar view

**Features nâng cao:**
- Friend system + accountability
- Notifications
- Advanced analytics
- Gamification (badges, points)

---

### **#3 - Split Bill & Tracking**
**Điểm tổng: 3.5/10**

```
Frontend Complexity:    ⭐⭐⭐☆☆ (3/5)
Backend Complexity:     ⭐⭐⭐☆☆ (3/5)
Integration:            ⭐☆☆☆☆ (1/5)
Algorithm:              ⭐⭐⭐⭐☆ (4/5) 👈 Phức tạp
DevOps:                 ⭐⭐☆☆☆ (2/5)
───────────────────────────────────
TOTAL:                  3.5/10
```

**Tại sao trung bình:**
- ✅ UI simple (expense list, add transaction)
- ⚠️ **Algorithm phức tạp**: Debt settlement optimization
- ⚠️ Multi-user complexity
- ⚠️ Currency handling

**Challenge chính:**
```
Bài toán: Minimize số lượng transactions
──────────────────────────────────────────
A owes $100, B owes $50, C paid $150
Naive: A→C $100, B→C $50 (2 transactions)
Optimal: A→C $100, B→C $50 (2 transactions) ✓

Nhưng với 5-10 người, thuật toán phức tạp hơn!
```

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js + Zustand + React Hook Form
Backend: Next.js API + Prisma
Database: PostgreSQL
Algorithm: Graph theory (debt optimization)
Real-time: Socket.io (optional, cho live updates)
Deploy: Vercel
```

**MVP (2 tuần):**
- Create group
- Add expenses
- Basic split (equal/custom)
- Show who owes whom

**Algorithm cần implement:**
- Debt simplification (graph-based)
- Multi-currency conversion
- Percentage-based splits
- Category-based settlements

---

## 🟡 LEVEL 4-6: INTERMEDIATE (Trung bình)

### **#4 - Money Tracker App**
**Điểm tổng: 4/10**

```
Frontend Complexity:    ⭐⭐⭐⭐☆ (4/5) 👈 Charts, filters
Backend Complexity:     ⭐⭐⭐☆☆ (3/5)
Integration:            ⭐⭐⭐☆☆ (3/5) AI optional
Algorithm:              ⭐⭐⭐☆☆ (3/5)
DevOps:                 ⭐⭐⭐☆☆ (3/5)
───────────────────────────────────
TOTAL:                  4/10
```

**Tại sao intermediate:**
- ⚠️ **Data visualization phức tạp**: Multi-level charts
- ⚠️ **Filter system**: Date range, categories, tags
- ⚠️ **Budget tracking**: Warnings, forecasting
- ⚠️ **Export/Import**: CSV, PDF reports
- ⚠️ **AI assistant** (optional): Tăng độ khó lên 6/10

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js + Redux Toolkit + Recharts/D3.js
Backend: Next.js + Prisma
Database: PostgreSQL (với proper indexing)
Charts: Recharts + Chart.js
AI: OpenAI API (optional)
Export: jsPDF, ExcelJS
Deploy: Vercel
```

**MVP (2-3 tuần):**
- Add transaction (income/expense)
- Categories
- Basic charts (daily/monthly)
- Summary dashboard

**Advanced Features:**
- Budget management (set limits, alerts)
- Recurring transactions
- Multiple accounts/wallets
- AI-powered categorization
- Financial insights & recommendations
- Export reports (PDF, Excel)

**Database Schema phức tạp:**
```sql
Users → Accounts → Transactions → Categories
                  ↓
            Budgets, Recurring, Tags
```

---

### **#5 - Smart Meal Planner**
**Điểm tổng: 5/10**

```
Frontend Complexity:    ⭐⭐⭐⭐☆ (4/5)
Backend Complexity:     ⭐⭐⭐⭐☆ (4/5)
Integration:            ⭐⭐⭐☆☆ (3/5)
Algorithm:              ⭐⭐⭐⭐⭐ (5/5) 👈 Rất phức tạp
DevOps:                 ⭐⭐⭐☆☆ (3/5)
───────────────────────────────────
TOTAL:                  5/10
```

**Tại sao khó hơn Money Tracker:**
- 🔥 **Recommendation Algorithm**: Multi-constraint optimization
- 🔥 **Nutritional calculations**: Calories, macros, portions
- 🔥 **Recipe scaling**: Ingredient adjustments
- ⚠️ **Search optimization**: Elasticsearch or Algolia
- ⚠️ **Data complexity**: Recipes, ingredients, nutrition

**Algorithm challenges:**
```javascript
// Constraint Satisfaction Problem
function suggestMeals(constraints) {
  return {
    budget: ≤ userBudget,
    calories: target ± 100,
    protein: ≥ minProtein,
    ingredients: in pantry,
    preferences: dietary restrictions,
    variety: không lặp lại món
  }
}

// Bài toán NP-hard, cần heuristic algorithms
```

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js 14 + Zustand + React Query
Backend: Fastify + Prisma
Database: PostgreSQL
Search: Elasticsearch hoặc Meilisearch
Cache: Redis (meal suggestions)
API: Spoonacular/Edamam (recipe data)
Algorithm: Custom recommendation engine
Deploy: Vercel + Railway
```

**MVP (3-4 tuần):**
- Input budget & calories
- Get 3 meal suggestions (static recipes)
- Basic nutritional info
- Save favorites

**Advanced:**
- AI-powered recommendations
- Pantry management (what's available)
- Weekly meal planning
- Grocery list generation
- Recipe substitutions
- Meal prep instructions

**Data Model:**
```
Users
  ↓
Preferences (dietary, allergies, budget)
  ↓
Pantry Items
  ↓
Meal Plans ← Recipes ← Ingredients → Nutrition
```

---

### **#6 - Insurance/Finance Assistant**
**Điểm tổng: 5.5/10**

```
Frontend Complexity:    ⭐⭐⭐⭐☆ (4/5)
Backend Complexity:     ⭐⭐⭐⭐☆ (4/5)
Integration:            ⭐⭐⭐⭐☆ (4/5) Email/SMS
Algorithm:              ⭐⭐⭐☆☆ (3/5)
DevOps:                 ⭐⭐⭐⭐☆ (4/5) Scheduled jobs
───────────────────────────────────
TOTAL:                  5.5/10
```

**Tại sao intermediate-advanced:**
- ⚠️ **Complex data model**: Contracts, payments, schedules
- ⚠️ **Scheduled jobs**: Reminder system (cron jobs)
- ⚠️ **Email/SMS automation**: SendGrid, Twilio
- ⚠️ **Timeline calculations**: Payment schedules, interest
- ⚠️ **Document storage**: Contract files, receipts

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js + Redux Toolkit + FullCalendar
Backend: NestJS (better for complex business logic)
Database: PostgreSQL + Prisma
Queue: BullMQ (scheduled reminders)
Storage: AWS S3 (documents)
Email: SendGrid
SMS: Twilio
Notifications: FCM
Deploy: Railway/Fly.io
```

**MVP (3 tuần):**
- Add insurance policy (details, premium, dates)
- Payment tracking
- Basic reminders (email)
- Dashboard (active policies)

**Advanced:**
- Loan amortization calculator
- Payment schedule optimization
- Document upload (OCR to extract data)
- Multi-policy comparison
- Claims tracking
- Auto-renewal reminders
- Investment portfolio (stocks, bonds)

**Business Logic phức tạp:**
```javascript
// Loan calculation
function calculateAmortization(principal, rate, years) {
  // Complex financial formulas
}

// Insurance premium calculations
function calculatePremium(age, coverage, term) {
  // Actuarial tables
}
```

---

## 🔴 LEVEL 7-8: ADVANCED (Khó)

### **#7 - Local Business Booster**
**Điểm tổng: 7/10**

```
Frontend Complexity:    ⭐⭐⭐⭐⭐ (5/5) PWA, multi-tenant
Backend Complexity:     ⭐⭐⭐⭐⭐ (5/5) Multi-tenant arch
Integration:            ⭐⭐⭐⭐☆ (4/5) Payment, QR
Algorithm:              ⭐⭐⭐☆☆ (3/5)
DevOps:                 ⭐⭐⭐⭐⭐ (5/5) PWA, caching
───────────────────────────────────
TOTAL:                  7/10
```

**Tại sao advanced:**
- 🔥 **Multi-tenant architecture**: Mỗi shop = 1 tenant
- 🔥 **PWA implementation**: Offline mode, service workers
- 🔥 **Real-time order system**: Kitchen display, notifications
- 🔥 **QR code system**: Generate, scan, process
- 🔥 **Payment integration**: VNPay, MoMo, banking APIs
- ⚠️ **Role-based access**: Owner, staff, customer
- ⚠️ **Inventory management**: Stock tracking

**Architecture Challenges:**
```javascript
// Multi-tenant isolation
┌─────────────────────────────────┐
│  Shared Infrastructure          │
├─────────────────────────────────┤
│  Tenant 1: Cafe A               │
│  - Menu, Orders, Staff          │
├─────────────────────────────────┤
│  Tenant 2: Restaurant B         │
│  - Menu, Orders, Staff          │
└─────────────────────────────────┘

// Database schema phức tạp
Tenants
  ↓
Stores → Menus → Items → Modifiers
       ↓
     Orders → OrderItems → Status History
       ↓
     Tables → QR Codes
       ↓
     Staff → Roles → Permissions
```

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js 14 (PWA) + Redux Toolkit
Backend: NestJS (microservices-ready)
Database: PostgreSQL + TypeORM
Real-time: Socket.io + Redis
Cache: Redis (menu, active orders)
Payment: VNPay/MoMo SDKs
QR: qrcode, jsQR
Storage: Cloudflare R2 (menu images)
Auth: JWT + refresh tokens
PWA: Workbox, IndexedDB
Deploy: DigitalOcean + Cloudflare
```

**MVP (4-5 tuần):**
- Store registration + setup
- Menu CRUD (items, prices, images)
- QR code generation
- Customer ordering (scan QR → order)
- Simple order dashboard
- Basic payment (cash)

**Advanced Features:**
- Real-time kitchen display system
- Payment gateway integration
- Table management
- Staff management (roles, shifts)
- Inventory tracking
- Analytics (bestsellers, revenue)
- Customer loyalty program
- Multiple locations
- Offline mode (PWA)

**Technical Challenges:**
```javascript
// 1. Multi-tenant data isolation
app.use((req, res, next) => {
  req.tenantId = extractTenantFromDomain(req);
  // Tất cả queries phải filter by tenantId
});

// 2. Real-time order updates
io.to(`tenant-${tenantId}`).emit('newOrder', order);

// 3. PWA offline queue
if (!navigator.onLine) {
  saveToIndexedDB(order);
  // Sync khi online
}

// 4. QR code security
const qrData = encrypt({
  tableId,
  tenantId,
  timestamp,
  signature
});
```

---

### **#8 - Crypto Investment Tracker**
**Điểm tổng: 7.5/10**

```
Frontend Complexity:    ⭐⭐⭐⭐⭐ (5/5) Real-time, charts
Backend Complexity:     ⭐⭐⭐⭐☆ (4/5)
Integration:            ⭐⭐⭐⭐⭐ (5/5) WebSocket, APIs
Algorithm:              ⭐⭐⭐⭐☆ (4/5) Portfolio calc
DevOps:                 ⭐⭐⭐⭐⭐ (5/5) Caching, perf
───────────────────────────────────
TOTAL:                  7.5/10
```

**Tại sao advanced:**
- 🔥 **Real-time WebSocket**: Price updates every second
- 🔥 **Performance optimization**: Handle 100+ coins
- 🔥 **Complex calculations**: Portfolio value, P&L, ROI
- 🔥 **Advanced charting**: Candlesticks, indicators (RSI, MACD)
- 🔥 **Multi-API integration**: CoinGecko, Binance, CoinMarketCap
- 🔥 **Caching strategy**: Redis with TTL, invalidation
- ⚠️ **Data synchronization**: Multiple sources, conflict resolution

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js 14 + Zustand + React Query
UI: shadcn/ui + TailwindCSS
Charts: Recharts + Lightweight Charts (TradingView)
Real-time: WebSocket (ws library)
Backend: Next.js API + tRPC
Database: PostgreSQL + Prisma
Cache: Redis (Upstash)
APIs: CoinGecko, Binance, CryptoCompare
Auth: NextAuth.js
Deploy: Vercel + Railway
```

**MVP (3-4 tuần):**
- Connect wallet (manual input: coin + amount)
- Fetch live prices (REST API)
- Portfolio value calculation
- Basic line chart
- Simple P&L display

**Advanced Features:**
- Real-time WebSocket (prices update live)
- Advanced charts (candlestick, volume, indicators)
- Price alerts (push notifications)
- Transaction history (buy/sell)
- Tax reporting (capital gains)
- DCA calculator
- Portfolio rebalancing suggestions
- News feed integration
- Multiple portfolios

**Technical Challenges:**

```javascript
// 1. WebSocket management
class CryptoWebSocket {
  constructor() {
    this.connections = new Map();
    this.reconnectAttempts = 0;
  }
  
  subscribe(symbols) {
    symbols.forEach(symbol => {
      this.ws.send(JSON.stringify({
        method: 'SUBSCRIBE',
        params: [`${symbol.toLowerCase()}@ticker`]
      }));
    });
  }
  
  handleReconnect() {
    // Exponential backoff
    setTimeout(() => this.connect(), 
      Math.min(1000 * 2 ** this.reconnectAttempts, 30000));
  }
}

// 2. Performance optimization
// Virtualize large lists
import { useVirtualizer } from '@tanstack/react-virtual';

// Memoize expensive calculations
const portfolioValue = useMemo(() => {
  return holdings.reduce((total, holding) => 
    total + (holding.amount * prices[holding.symbol]), 0
  );
}, [holdings, prices]);

// 3. Caching strategy
// Redis với TTL
await redis.setex(`price:${symbol}`, 60, price); // Cache 1 phút

// Client-side caching
const { data } = useQuery({
  queryKey: ['prices', symbols],
  queryFn: fetchPrices,
  staleTime: 30000, // 30 giây
  cacheTime: 300000 // 5 phút
});

// 4. Complex portfolio calculations
function calculatePortfolio(transactions) {
  const holdings = {};
  const realized = { profit: 0, loss: 0 };
  
  // FIFO/LIFO accounting
  transactions.forEach(tx => {
    if (tx.type === 'BUY') {
      holdings[tx.coin] = holdings[tx.coin] || [];
      holdings[tx.coin].push({ 
        amount: tx.amount, 
        price: tx.price,
        date: tx.date 
      });
    } else if (tx.type === 'SELL') {
      // Calculate realized gains
      const batches = holdings[tx.coin];
      let remaining = tx.amount;
      
      while (remaining > 0 && batches.length > 0) {
        const batch = batches[0];
        const sellAmount = Math.min(batch.amount, remaining);
        const profit = (tx.price - batch.price) * sellAmount;
        
        if (profit > 0) realized.profit += profit;
        else realized.loss += Math.abs(profit);
        
        batch.amount -= sellAmount;
        remaining -= sellAmount;
        
        if (batch.amount === 0) batches.shift();
      }
    }
  });
  
  return { holdings, realized };
}
```

**Performance Requirements:**
- ⚡ Price updates: < 100ms latency
- ⚡ Chart rendering: 60 FPS
- ⚡ Initial load: < 2s
- ⚡ Handle 1000+ transactions without lag

---

### **#9 - Freelance Task & Payment Manager**
**Điểm tổng: 8/10**

```
Frontend Complexity:    ⭐⭐⭐⭐⭐ (5/5) Kanban, real-time
Backend Complexity:     ⭐⭐⭐⭐⭐ (5/5) Auth, payments
Integration:            ⭐⭐⭐⭐⭐ (5/5) Stripe, emails
Algorithm:              ⭐⭐⭐☆☆ (3/5)
DevOps:                 ⭐⭐⭐⭐☆ (4/5)
───────────────────────────────────
TOTAL:                  8/10
```

**Tại sao very advanced:**
- 🔥 **Complex authentication**: Multi-role (freelancer vs client)
- 🔥 **Payment integration**: Stripe Connect (platform payments)
- 🔥 **Real-time collaboration**: Socket.io for live updates
- 🔥 **File management**: Contract uploads, invoices, deliverables
- 🔥 **Email automation**: Notifications, reminders, invoices
- 🔥 **Advanced UI**: Drag-drop Kanban, inline editing
- ⚠️ **Invoice generation**: PDF with calculations
- ⚠️ **Escrow system**: Hold payments until completion
- ⚠️ **Dispute resolution**: Milestone tracking

**Tech Stack gợi ý:**
```javascript
Frontend: Remix (server-side focused) + TypeScript
State: Redux Toolkit + RTK Query
UI: Chakra UI + Framer Motion
DnD: @dnd-kit/core (drag-drop kanban)
Backend: Node.js + Express + TypeScript
Database: MongoDB + Mongoose (flexible schema)
Real-time: Socket.io
Payment: Stripe Connect
File: AWS S3 + presigned URLs
Email: SendGrid (transactional)
PDF: PDFKit
Auth: Passport.js + JWT
Queue: Bull (email jobs)
Deploy: Fly.io
```

**MVP (4-5 tuần):**
- User registration (freelancer/client roles)
- Create project
- Add tasks (to-do list)
- Basic task assignment
- Simple payment request (manual)

**Advanced Features:**
- Kanban board (drag-drop)
- Real-time updates (multiplayer editing)
- Stripe integration (escrow, milestones)
- Time tracking
- Invoice generation (PDF)
- Contract management
- File attachments
- Comments & discussions
- Notifications (email, in-app)
- Analytics (earnings, time spent)

**Technical Challenges:**

```javascript
// 1. Multi-role authentication
interface User {
  id: string;
  role: 'freelancer' | 'client';
  permissions: Permission[];
}

// Middleware check
function requireRole(role: UserRole) {
  return (req, res, next) => {
    if (req.user.role !== role) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    next();
  };
}

// 2. Stripe Connect integration
// Platform receives commission, freelancer gets paid
async function createConnectedAccount(freelancer) {
  const account = await stripe.accounts.create({
    type: 'express',
    country: 'US',
    email: freelancer.email,
    capabilities: {
      card_payments: { requested: true },
      transfers: { requested: true }
    }
  });
  
  return account;
}

async function createEscrowPayment(project, milestone) {
  // Client pays
  const paymentIntent = await stripe.paymentIntents.create({
    amount: milestone.amount * 100,
    currency: 'usd',
    customer: project.client.stripeCustomerId,
    transfer_data: {
      destination: project.freelancer.stripeAccountId,
    },
    metadata: {
      projectId: project.id,
      milestoneId: milestone.id
    },
    // Hold funds until milestone approved
    capture_method: 'manual'
  });
  
  return paymentIntent;
}

// Release payment khi client approve
async function releasePayment(paymentIntentId) {
  await stripe.paymentIntents.capture(paymentIntentId, {
    application_fee_amount: calculatePlatformFee(amount) // 5-10%
  });
}

// 3. Real-time collaboration
io.on('connection', (socket) => {
  socket.on('join-project', (projectId) => {
    socket.join(`project-${projectId}`);
  });
  
  socket.on('task-update', (data) => {
    // Broadcast to all in project except sender
    socket.to(`project-${data.projectId}`).emit('task-updated', data);
  });
  
  socket.on('typing', (data) => {
    socket.to(`project-${data.projectId}`).emit('user-typing', {
      user: data.user,
      taskId: data.taskId
    });
  });
});

// 4. Invoice PDF generation
import PDFDocument from 'pdfkit';

async function generateInvoice(project, milestone) {
  const doc = new PDFDocument();
  const stream = doc.pipe(fs.createWriteStream('invoice.pdf'));
  
  // Header
  doc.fontSize(20).text('INVOICE', { align: 'center' });
  doc.moveDown();
  
  // Details
  doc.fontSize(12)
     .text(`Invoice #: ${invoice.number}`)
     .text(`Date: ${new Date().toLocaleDateString()}`)
     .text(`Due Date: ${invoice.dueDate}`)
     .moveDown();
  
  // Line items
  milestone.tasks.forEach(task => {
    doc.text(`${task.name}: $${task.price}`);
  });
  
  doc.moveDown();
  doc.fontSize(14).text(`Total: $${milestone.amount}`, { bold: true });
  
  doc.end();
  await new Promise(resolve => stream.on('finish', resolve));
  
  return 'invoice.pdf';
}

// 5. File upload security
// Presigned URLs for direct S3 upload
async function getUploadUrl(filename, projectId, userId) {
  // Validate user has access to project
  const project = await Project.findById(projectId);
  if (!project.hasAccess(userId)) {
    throw new Error('Unauthorized');
  }
  
  const key = `projects/${projectId}/${userId}/${Date.now()}-${filename}`;
  
  const url = await s3.getSignedUrlPromise('putObject', {
    Bucket: process.env.S3_BUCKET,
    Key: key,
    Expires: 300, // 5 minutes
    ContentType: mime.lookup(filename)
  });
  
  return { url, key };
}
```

**Database Schema:**
```javascript
Users (freelancers, clients)
  ↓
Projects
  ↓
Milestones ← Payments (Stripe)
  ↓
Tasks ← Comments ← Attachments
  ↓
TimeEntries
  ↓
Invoices
```

---

## 🔥 LEVEL 9-10: EXPERT (Rất khó)

### **#10 - AI Study Assistant**
**Điểm tổng: 9/10** 🏆

```
Frontend Complexity:    ⭐⭐⭐⭐⭐ (5/5) Streaming, RSC
Backend Complexity:     ⭐⭐⭐⭐⭐ (5/5) AI, queue
Integration:            ⭐⭐⭐⭐⭐ (5/5) OpenAI, vector DB
Algorithm:              ⭐⭐⭐⭐⭐ (5/5) Spaced repetition
DevOps:                 ⭐⭐⭐⭐☆ (4/5)
───────────────────────────────────
TOTAL:                  9/10
```

**Tại sao expert level:**
- 🔥 **AI integration**: OpenAI API, prompt engineering
- 🔥 **Vector database**: Pinecone, embeddings, semantic search
- 🔥 **Streaming responses**: Server-Sent Events, React Suspense
- 🔥 **Complex algorithm**: Spaced Repetition System (SM-2/SM-17)
- 🔥 **Job queue**: BullMQ for async AI processing
- 🔥 **React Server Components**: Cutting-edge Next.js
- ⚠️ **Natural language processing**: Text analysis, extraction
- ⚠️ **OCR integration**: Image to text (Tesseract, Google Vision)
- ⚠️ **Audio processing**: Speech-to-text (Whisper API)

**Tech Stack gợi ý:**
```javascript
Frontend: Next.js 14 (App Router, RSC) + TypeScript
State: Jotai (atomic, perfect for complex forms)
UI: Radix UI primitives + Custom design
AI: OpenAI API + Langchain
Vector: Pinecone (embeddings, similarity search)
Backend: Next.js + Server Actions
Database: Supabase (PostgreSQL + Auth + Storage)
Queue: BullMQ + Redis
OCR: Google Cloud Vision API
Audio: OpenAI Whisper
Email: Resend
Deploy: Vercel
```

**MVP (5-6 tuần):**
- Input text (paste notes)
- AI generates 5 flashcards
- Basic flip animation
- Save to database
- Simple quiz mode

**Advanced Features:**
- Spaced repetition algorithm (SM-2)
- AI-powered quiz generation
- Voice input (Whisper API)
- Image OCR (scan textbooks)
- Collaborative decks
- Analytics (retention rate, weak areas)
- Adaptive difficulty
- Multi-language support
- Export to Anki

**Technical Challenges:**

```javascript
// 1. OpenAI Streaming với React Server Components
// app/api/generate/route.ts
import { OpenAIStream, StreamingTextResponse } from 'ai';
import { Configuration, OpenAIApi } from 'openai-edge';

export const runtime = 'edge';

export async function POST(req: Request) {
  const { text } = await req.json();
  
  const prompt = `
    Analyze the following text and create flashcards:
    
    ${text}
    
    Generate 5 flashcards in JSON format:
    [
      { "question": "...", "answer": "...", "difficulty": 1-5 }
    ]
  `;
  
  const response = await openai.createChatCompletion({
    model: 'gpt-4-turbo',
    messages: [{ role: 'user', content: prompt }],
    stream: true,
    temperature: 0.7,
  });
  
  const stream = OpenAIStream(response);
  return new StreamingTextResponse(stream);
}

// Client component
'use client';
import { useCompletion } from 'ai/react';

export function FlashcardGenerator() {
  const { completion, input, handleInputChange, handleSubmit, isLoading } = 
    useCompletion({
      api: '/api/generate',
      onFinish: (prompt, completion) => {
        const flashcards = JSON.parse(completion);
        saveFlashcards(flashcards);
      }
    });
  
  return (
    <form onSubmit={handleSubmit}>
      <textarea value={input} onChange={handleInputChange} />
      <button type="submit" disabled={isLoading}>
        {isLoading ? 'Generating...' : 'Create Flashcards'}
      </button>
      {completion && <div>{completion}</div>}
    </form>
  );
}

// 2. Vector Database - Semantic Search
import { PineconeClient } from '@pinecone-database/pinecone';
import { OpenAIEmbeddings } from 'langchain/embeddings/openai';

class FlashcardVectorStore {
  private pinecone: PineconeClient;
  private embeddings: OpenAIEmbeddings;
  
  async addFlashcard(flashcard: Flashcard) {
    // Generate embedding
    const embedding = await this.embeddings.embedQuery(
      `${flashcard.question} ${flashcard.answer}`
    );
    
    // Store in Pinecone
    await this.pinecone.Index('flashcards').upsert([{
      id: flashcard.id,
      values: embedding,
      metadata: {
        question: flashcard.question,
        answer: flashcard.answer,
        deckId: flashcard.deckId,
        difficulty: flashcard.difficulty
      }
    }]);
  }
  
  async findSimilar(query: string, limit = 5) {
    const queryEmbedding = await this.embeddings.embedQuery(query);
    
    const results = await this.pinecone.Index('flashcards').query({
      vector: queryEmbedding,
      topK: limit,
      includeMetadata: true
    });
    
    return results.matches.map(match => ({
      ...match.metadata,
      similarity: match.score
    }));
  }
  
  // Find related flashcards for review
  async getSuggestedReviews(userId: string, topic: string) {
    const weakCards = await this.getWeakCards(userId);
    const relatedCards = await this.findSimilar(topic, 10);
    
    // Merge and prioritize
    return this.prioritizeReview(weakCards, relatedCards);
  }
}

// 3. Spaced Repetition Algorithm (SM-2)
interface CardReview {
  cardId: string;
  easeFactor: number;  // 1.3 - 2.5
  interval: number;    // days
  repetitions: number;
  nextReview: Date;
}

class SpacedRepetitionSystem {
  /**
   * SM-2 Algorithm
   * @param quality - 0 (complete blackout) to 5 (perfect response)
   */
  calculateNextReview(card: CardReview, quality: number): CardReview {
    let { easeFactor, interval, repetitions } = card;
    
    if (quality >= 3) {
      // Correct response
      if (repetitions === 0) {
        interval = 1;
      } else if (repetitions === 1) {
        interval = 6;
      } else {
        interval = Math.round(interval * easeFactor);
      }
      repetitions += 1;
    } else {
      // Incorrect response - restart
      repetitions = 0;
      interval = 1;
    }
    
    // Update ease factor
    easeFactor = Math.max(
      1.3,
      easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))
    );
    
    const nextReview = new Date();
    nextReview.setDate(nextReview.getDate() + interval);
    
    return {
      ...card,
      easeFactor,
      interval,
      repetitions,
      nextReview
    };
  }
  
  // Get cards due for review
  async getDueCards(userId: string): Promise<Flashcard[]> {
    const reviews = await db.cardReview.findMany({
      where: {
        userId,
        nextReview: { lte: new Date() }
      },
      include: { flashcard: true },
      orderBy: { nextReview: 'asc' }
    });
    
    return reviews.map(r => r.flashcard);
  }
  
  // Advanced: Adjust based on user performance
  adaptiveDifficulty(userStats: UserStats): number {
    const { accuracy, avgResponseTime, streak } = userStats;
    
    if (accuracy > 0.9 && avgResponseTime < 3000) {
      return 1.2; // Increase difficulty
    } else if (accuracy < 0.6) {
      return 0.8; // Decrease difficulty
    }
    
    return 1.0; // Maintain
  }
}

// 4. Job Queue cho AI processing (tránh timeout)
import { Queue, Worker } from 'bullmq';

const flashcardQueue = new Queue('flashcard-generation', {
  connection: {
    host: process.env.REDIS_HOST,
    port: 6379
  }
});

// Add job
export async function generateFlashcardsAsync(text: string, userId: string) {
  const job = await flashcardQueue.add('generate', {
    text,
    userId,
    timestamp: Date.now()
  }, {
    attempts: 3,
    backoff: {
      type: 'exponential',
      delay: 2000
    }
  });
  
  return job.id;
}

// Worker process
const worker = new Worker('flashcard-generation', async (job) => {
  const { text, userId } = job.data;
  
  // Long-running AI task
  const flashcards = await openai.createChatCompletion({
    model: 'gpt-4-turbo',
    messages: [
      {
        role: 'system',
        content: 'You are an expert at creating educational flashcards.'
      },
      {
        role: 'user',
        content: `Create flashcards from: ${text}`
      }
    ]
  });
  
  const parsed = JSON.parse(flashcards.choices[0].message.content);
  
  // Generate embeddings in parallel
  await Promise.all(
    parsed.map(card => vectorStore.addFlashcard(card))
  );
  
  // Save to database
  await db.flashcard.createMany({
    data: parsed.map(card => ({
      ...card,
      userId,
      deckId: job.data.deckId
    }))
  });
  
  // Notify user (WebSocket/Pusher)
  await notifyUser(userId, {
    type: 'flashcards_ready',
    count: parsed.length,
    jobId: job.id
  });
  
  return parsed;
}, {
  connection: { host: process.env.REDIS_HOST, port: 6379 }
});

// 5. OCR Integration - Scan textbooks
import vision from '@google-cloud/vision';

export async function extractTextFromImage(imageBuffer: Buffer) {
  const client = new vision.ImageAnnotatorClient();
  
  const [result] = await client.textDetection(imageBuffer);
  const detections = result.textAnnotations;
  
  if (!detections || detections.length === 0) {
    throw new Error('No text found in image');
  }
  
  const fullText = detections[0].description;
  
  // Clean up and structure
  const cleaned = fullText
    .replace(/\n{3,}/g, '\n\n')
    .trim();
  
  // AI post-processing
  const structured = await openai.createChatCompletion({
    model: 'gpt-4',
    messages: [{
      role: 'user',
      content: `
        This text was extracted from a textbook via OCR. 
        Clean it up and format properly:
        
        ${cleaned}
      `
    }]
  });
  
  return structured.choices[0].message.content;
}

// 6. Advanced Analytics
interface StudyAnalytics {
  retention: {
    daily: number[];
    weekly: number[];
    overall: number;
  };
  weakAreas: {
    topic: string;
    accuracy: number;
    avgTime: number;
  }[];
  optimalStudyTime: number; // minutes per day
  prediction: {
    examReadiness: number; // 0-100%
    suggestedReview: Date;
  };
}

async function calculateAnalytics(userId: string): Promise<StudyAnalytics> {
  const reviews = await db.cardReview.findMany({
    where: { userId },
    include: { flashcard: { include: { deck: true } } },
    orderBy: { reviewedAt: 'desc' },
    take: 1000
  });
  
  // Calculate retention using forgetting curve
  const retention = reviews.reduce((acc, review, idx) => {
    const daysSinceReview = daysBetween(review.reviewedAt, new Date());
    const predictedRetention = Math.exp(-daysSinceReview / review.interval);
    
    return acc + predictedRetention;
  }, 0) / reviews.length;
  
  // Identify weak areas
  const deckStats = groupBy(reviews, 'flashcard.deckId');
  const weakAreas = Object.entries(deckStats)
    .map(([deckId, reviews]) => ({
      topic: reviews[0].flashcard.deck.name,
      accuracy: reviews.filter(r => r.quality >= 3).length / reviews.length,
      avgTime: average(reviews.map(r => r.responseTime))
    }))
    .filter(area => area.accuracy < 0.7)
    .sort((a, b) => a.accuracy - b.accuracy);
  
  // ML prediction (simplified)
  const examReadiness = calculateReadiness(reviews);
  
  return {
    retention: {
      daily: calculateDailyRetention(reviews),
      weekly: calculateWeeklyRetention(reviews),
      overall: retention
    },
    weakAreas,
    optimalStudyTime: calculateOptimalTime(reviews),
    prediction: {
      examReadiness,
      suggestedReview: suggestNextReview(reviews, examReadiness)
    }
  };
}

// 7. Collaborative Learning
interface StudyGroup {
  id: string;
  name: string;
  members: User[];
  sharedDecks: Deck[];
  leaderboard: {
    userId: string;
    score: number;
    streak: number;
  }[];
}

async function shareFlashcard(cardId: string, groupId: string) {
  // Duplicate card for group members
  const card = await db.flashcard.findUnique({ where: { id: cardId } });
  const group = await db.studyGroup.findUnique({
    where: { id: groupId },
    include: { members: true }
  });
  
  await Promise.all(
    group.members.map(member =>
      db.flashcard.create({
        data: {
          ...card,
          userId: member.id,
          sharedFrom: card.userId,
          groupId
        }
      })
    )
  );
  
  // Real-time notification
  pusher.trigger(`group-${groupId}`, 'new-flashcard', {
    card,
    sharedBy: card.user.name
  });
}
```

**Database Schema (Supabase):**
```sql
-- Users
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Decks
CREATE TABLE decks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  name TEXT NOT NULL,
  description TEXT,
  is_public BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Flashcards
CREATE TABLE flashcards (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  deck_id UUID REFERENCES decks(id) ON DELETE CASCADE,
  question TEXT NOT NULL,
  answer TEXT NOT NULL,
  difficulty INT CHECK (difficulty BETWEEN 1 AND 5),
  image_url TEXT,
  audio_url TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  -- Vector embedding (pgvector extension)
  embedding VECTOR(1536)
);

-- Card Reviews (Spaced Repetition Data)
CREATE TABLE card_reviews (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  card_id UUID REFERENCES flashcards(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id),
  quality INT CHECK (quality BETWEEN 0 AND 5),
  ease_factor FLOAT DEFAULT 2.5,
  interval INT DEFAULT 1,
  repetitions INT DEFAULT 0,
  next_review TIMESTAMP,
  response_time INT, -- milliseconds
  reviewed_at TIMESTAMP DEFAULT NOW(),
  
  INDEX idx_next_review (user_id, next_review),
  INDEX idx_card_user (card_id, user_id)
);

-- Study Groups
CREATE TABLE study_groups (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMP DEFAULT NOW()
);

-- Study Sessions
CREATE TABLE study_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  started_at TIMESTAMP DEFAULT NOW(),
  ended_at TIMESTAMP,
  cards_reviewed INT,
  accuracy FLOAT
);

-- AI Generation Jobs
CREATE TABLE generation_jobs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id),
  status TEXT CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  input_text TEXT,
  result JSONB,
  error TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);
```

---

## 📊 Bảng Tổng Kết

| # | Project | Điểm | Frontend | Backend | Integration | Algorithm | DevOps | Thời gian |
|---|---------|------|----------|---------|-------------|-----------|--------|-----------|
| 1 | Event Helper | 2.5 | ⭐⭐ | ⭐⭐ | ⭐ | ⭐ | ⭐⭐ | 1-2 tuần |
| 2 | Habit Tracker | 3.0 | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | 1.5-2 tuần |
| 3 | Split Bill | 3.5 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐ | ⭐⭐⭐⭐ | ⭐⭐ | 2-3 tuần |
| 4 | Money Tracker | 4.0 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 2-3 tuần |
| 5 | Meal Planner | 5.0 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | 3-4 tuần |
| 6 | Insurance/Finance | 5.5 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | 3-4 tuần |
| 7 | Business Booster | 7.0 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 4-5 tuần |
| 8 | Crypto Tracker | 7.5 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 3-4 tuần |
| 9 | Freelance Manager | 8.0 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | 4-5 tuần |
| 10 | AI Study Assistant | 9.0 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | 5-6 tuần |

---
