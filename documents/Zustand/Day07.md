# üìò Day 7 ‚Äì Async Actions & API Calls (v·ªõi Error Logging)

## 1. Kh√°i ni·ªám

Trong ·ª©ng d·ª•ng th·ª±c t·∫ø, state kh√¥ng ch·ªâ l√† boolean hay counter. Ta c·∫ßn qu·∫£n l√Ω **d·ªØ li·ªáu b·∫•t ƒë·ªìng b·ªô** nh∆∞:

* Fetch API t·ª´ backend.
* G·ª≠i form data (login, signup).
* C·∫≠p nh·∫≠t DB (CRUD).

V·ªõi Zustand, async action ch·ªâ ƒë∆°n gi·∫£n l√† **h√†m async trong store**. Nh∆∞ng ƒë·ªÉ enterprise-friendly, ta c·∫ßn:

* Qu·∫£n l√Ω **loading / error state**.
* Log l·ªói (Sentry/metrics).
* Kh√¥ng re-render to√†n b·ªô UI kh√¥ng c·∫ßn thi·∫øt.

---

## 2. C·∫•u tr√∫c chu·∫©n trong c√¥ng ty l·ªõn

### store/userStore.ts

```ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { useMetricsStore } from './metricsStore'

interface User {
  id: number
  name: string
  email: string
}

interface UserState {
  users: User[]
  loading: boolean
  error: string | null
  fetchUsers: () => Promise<void>
}

export const useUserStore = create<UserState>()(
  devtools((set) => ({
    users: [],
    loading: false,
    error: null,

    fetchUsers: async () => {
      set({ loading: true, error: null }, false, 'users/fetch/start')

      try {
        const res = await fetch('https://jsonplaceholder.typicode.com/users')
        if (!res.ok) throw new Error(`API failed with ${res.status}`)
        const data: User[] = await res.json()

        set({ users: data, loading: false }, false, 'users/fetch/success')
        useMetricsStore.getState().logAction('users/fetch/success')
      } catch (err: any) {
        set({ error: err.message, loading: false }, false, 'users/fetch/error')
        useMetricsStore.getState().logError(`users/fetch/error: ${err.message}`)
      }
    },
  }))
)
```

---

### Component: UserList.tsx

```tsx
import React, { useEffect } from 'react'
import { useUserStore } from '../store/userStore'

export const UserList = () => {
  const { users, loading, error, fetchUsers } = useUserStore()

  useEffect(() => {
    fetchUsers()
  }, [fetchUsers])

  if (loading) return <p>‚è≥ Loading users...</p>
  if (error) return <p>‚ùå Error: {error}</p>

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>
          {u.name} ({u.email})
        </li>
      ))}
    </ul>
  )
}
```

---

## 3. Middleware + Logging Flow

1. `fetchUsers()` b·∫Øt ƒë·∫ßu ‚Üí log `"users/fetch/start"`.
2. N·∫øu th√†nh c√¥ng ‚Üí log `"users/fetch/success"`.
3. N·∫øu l·ªói ‚Üí logError `"users/fetch/error: <message>"`.
4. Metrics store s·∫Ω tƒÉng `errors` v√† c√≥ th·ªÉ trigger c·∫£nh b√°o.

---

## 4. Best Practices Enterprise

* **Always track `loading/error`** ‚Üí gi√∫p UI consistent.
* **Log l·ªói c·∫£ ·ªü state + external tool** ‚Üí kh√¥ng m·∫•t trace.
* **Kh√¥ng ƒë·ªÉ UI re-render to√†n b·ªô**: ch·ªâ subscribe v√†o slice (`users`, `loading`, `error`).
* **Error category r√µ r√†ng**: `"users/fetch/error"` thay v√¨ ch·ªâ `"error"`.
* **Retry strategy**: cho ph√©p g·ªçi l·∫°i API n·∫øu fail.

---

## 5. Mini Coding Challenge

üëâ Vi·∫øt th√™m m·ªôt action `addUser(name: string, email: string)`:

* G·ª≠i POST API gi·∫£ ([https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)).
* N·∫øu th√†nh c√¥ng ‚Üí update users state.
* N·∫øu l·ªói ‚Üí logError v√†o metrics.

**Solution m·∫´u cho challenge addUser()** v·ªõi chu·∫©n enterprise: c√≥ **optimistic update** + **rollback khi fail**.

---

# üöÄ Challenge Solution ‚Äì `addUser()`

## 1. Store v·ªõi `addUser`

```ts
// store/userStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { useMetricsStore } from './metricsStore'

interface User {
  id: number
  name: string
  email: string
}

interface UserState {
  users: User[]
  loading: boolean
  error: string | null
  fetchUsers: () => Promise<void>
  addUser: (name: string, email: string) => Promise<void>
}

export const useUserStore = create<UserState>()(
  devtools((set, get) => ({
    users: [],
    loading: false,
    error: null,

    fetchUsers: async () => {
      set({ loading: true, error: null }, false, 'users/fetch/start')
      try {
        const res = await fetch('https://jsonplaceholder.typicode.com/users')
        if (!res.ok) throw new Error(`API failed with ${res.status}`)
        const data: User[] = await res.json()
        set({ users: data, loading: false }, false, 'users/fetch/success')
        useMetricsStore.getState().logAction('users/fetch/success')
      } catch (err: any) {
        set({ error: err.message, loading: false }, false, 'users/fetch/error')
        useMetricsStore.getState().logError(`users/fetch/error: ${err.message}`)
      }
    },

    addUser: async (name, email) => {
      const tempId = Date.now() // fake ID cho optimistic update
      const newUser: User = { id: tempId, name, email }

      // Optimistic update
      set(
        (state) => ({ users: [...state.users, newUser] }),
        false,
        'users/add/optimistic'
      )

      try {
        const res = await fetch('https://jsonplaceholder.typicode.com/users', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(newUser),
        })
        if (!res.ok) throw new Error(`POST failed with ${res.status}`)

        const savedUser: User = await res.json()

        // Replace tempId b·∫±ng id th·∫≠t t·ª´ API
        set(
          (state) => ({
            users: state.users.map((u) =>
              u.id === tempId ? { ...savedUser, id: savedUser.id } : u
            ),
          }),
          false,
          'users/add/success'
        )
        useMetricsStore.getState().logAction('users/add/success')
      } catch (err: any) {
        // Rollback n·∫øu fail
        set(
          (state) => ({
            users: state.users.filter((u) => u.id !== tempId),
            error: err.message,
          }),
          false,
          'users/add/error'
        )
        useMetricsStore.getState().logError(`users/add/error: ${err.message}`)
      }
    },
  }))
)
```

---

## 2. Component: AddUserForm.tsx

```tsx
import React, { useState } from 'react'
import { useUserStore } from '../store/userStore'

export const AddUserForm = () => {
  const [name, setName] = useState('')
  const [email, setEmail] = useState('')
  const addUser = useUserStore((s) => s.addUser)
  const error = useUserStore((s) => s.error)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!name || !email) return
    await addUser(name, email)
    setName('')
    setEmail('')
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Name"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <input
        type="email"
        placeholder="Email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button type="submit">Add User</button>
      {error && <p style={{ color: 'red' }}>‚ùå {error}</p>}
    </form>
  )
}
```

---

## 3. Flow chu·∫©n

1. User submit ‚Üí UI update ngay v·ªõi `optimistic state`.
2. N·∫øu API th√†nh c√¥ng ‚Üí replace `tempId` b·∫±ng `realId`.
3. N·∫øu API fail ‚Üí rollback, remove user v·ª´a th√™m, log error.

---

## 4. Best Practices

* **Optimistic UI** gi√∫p UX nhanh, kh√¥ng ph·∫£i ch·ªù API.
* **Rollback** ƒë·∫£m b·∫£o d·ªØ li·ªáu UI = d·ªØ li·ªáu backend.
* **Action log r√µ r√†ng**: `add/optimistic ‚Üí add/success ‚Üí add/error`.
* **Error log** ƒëi k√®m rollback ‚Üí d·ªÖ trace khi debug.

---
N√¢ng c·∫•p `addUser()` v·ªõi **retry strategy** (t·ª± ƒë·ªông th·ª≠ l·∫°i t·ªëi ƒëa 3 l·∫ßn n·∫øu API fail). ƒê√¢y l√† pattern r·∫•t hay g·∫∑p trong **enterprise app** (network kh√¥ng ·ªïn ƒë·ªãnh, API rate limit, server t·∫°m l·ªói).

---

# üöÄ `addUser()` v·ªõi Retry Strategy

## 1. Store v·ªõi Retry

```ts
// store/userStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { useMetricsStore } from './metricsStore'

interface User {
  id: number
  name: string
  email: string
}

interface UserState {
  users: User[]
  loading: boolean
  error: string | null
  fetchUsers: () => Promise<void>
  addUser: (name: string, email: string) => Promise<void>
}

export const useUserStore = create<UserState>()(
  devtools((set, get) => ({
    users: [],
    loading: false,
    error: null,

    fetchUsers: async () => {
      set({ loading: true, error: null }, false, 'users/fetch/start')
      try {
        const res = await fetch('https://jsonplaceholder.typicode.com/users')
        if (!res.ok) throw new Error(`API failed with ${res.status}`)
        const data: User[] = await res.json()
        set({ users: data, loading: false }, false, 'users/fetch/success')
        useMetricsStore.getState().logAction('users/fetch/success')
      } catch (err: any) {
        set({ error: err.message, loading: false }, false, 'users/fetch/error')
        useMetricsStore.getState().logError(`users/fetch/error: ${err.message}`)
      }
    },

    addUser: async (name, email) => {
      const tempId = Date.now()
      const newUser: User = { id: tempId, name, email }

      // Optimistic update
      set(
        (state) => ({ users: [...state.users, newUser] }),
        false,
        'users/add/optimistic'
      )

      let attempt = 0
      let success = false
      let lastError = null

      while (attempt < 3 && !success) {
        try {
          attempt++
          const res = await fetch('https://jsonplaceholder.typicode.com/users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newUser),
          })

          if (!res.ok) throw new Error(`POST failed: ${res.status}`)
          const savedUser: User = await res.json()

          // Replace tempId b·∫±ng realId
          set(
            (state) => ({
              users: state.users.map((u) =>
                u.id === tempId ? { ...savedUser, id: savedUser.id } : u
              ),
            }),
            false,
            'users/add/success'
          )
          useMetricsStore.getState().logAction(`users/add/success (attempt ${attempt})`)
          success = true
        } catch (err: any) {
          lastError = err
          useMetricsStore
            .getState()
            .logError(`users/add/error attempt ${attempt}: ${err.message}`)

          // delay gi·ªØa c√°c l·∫ßn retry (exponential backoff)
          await new Promise((res) => setTimeout(res, attempt * 1000))
        }
      }

      if (!success) {
        // Rollback n·∫øu fail c·∫£ 3 l·∫ßn
        set(
          (state) => ({
            users: state.users.filter((u) => u.id !== tempId),
            error: lastError?.message || 'Unknown error',
          }),
          false,
          'users/add/failed-after-retries'
        )
      }
    },
  }))
)
```

---

## 2. Gi·∫£i th√≠ch c∆° ch·∫ø

* **Optimistic update**: user th·∫•y k·∫øt qu·∫£ ngay.
* **Retry loop (3 l·∫ßn)**: n·∫øu API fail ‚Üí th·ª≠ l·∫°i v·ªõi delay tƒÉng d·∫ßn (1s ‚Üí 2s ‚Üí 3s).
* **Log chi ti·∫øt**: `users/add/error attempt X` gi√∫p team dev trace d·ªÖ.
* **Rollback cu·ªëi c√πng**: ƒë·∫£m b·∫£o kh√¥ng gi·ªØ state sai.

---

## 3. L·ª£i √≠ch trong c√¥ng ty l·ªõn

* Tr√°nh UX t·ªá do API fail 1 l·∫ßn ‚Üí h·ªèng flow.
* C√≥ **resilience** (kh·∫£ nƒÉng ch·ªëng ch·ªãu) khi API load cao.
* Logging chi ti·∫øt gi√∫p **DevOps** ph√¢n t√≠ch t·ª∑ l·ªá l·ªói.
---

# üìå Day 7: Async Actions & API Calls trong Zustand

## üéØ M·ª•c ti√™u h·ªçc

* Bi·∫øt c√°ch vi·∫øt **async actions** (h√†m b·∫•t ƒë·ªìng b·ªô trong store).
* Qu·∫£n l√Ω **loading, error, data** theo best practices.
* Hi·ªÉu khi n√†o ƒë·ªÉ async logic trong Zustand, khi n√†o t√°ch ra (React Query).
* Th·ª±c h√†nh CRUD v·ªõi API gi·∫£.
* Bi·∫øt c√°ch log l·ªói v√† rollback state trong t√¨nh hu·ªëng fail.

---

## üìù TL;DR

Zustand c√≥ th·ªÉ qu·∫£n l√Ω **UI state + local async calls** r·∫•t t·ªët. Tuy nhi√™n v·ªõi **server state** ph·ª©c t·∫°p (pagination, caching, sync nhi·ªÅu tab) ‚Üí n√™n k·∫øt h·ª£p v·ªõi **React Query**.

---

## üîç N·ªôi dung chi ti·∫øt

### 1. C√∫ ph√°p c∆° b·∫£n async trong Zustand

```ts
// v√≠ d·ª• nh·ªè
const useUserStore = create<UserState>((set) => ({
  users: [],
  loading: false,
  error: null,

  fetchUsers: async () => {
    set({ loading: true, error: null })
    try {
      const res = await fetch('/api/users')
      const data = await res.json()
      set({ users: data, loading: false })
    } catch (err: any) {
      set({ error: err.message, loading: false })
    }
  },
}))
```

> ‚ö° ƒêi·ªÉm c·∫ßn nh·ªõ: Zustand kh√¥ng c·∫ßn `thunk` nh∆∞ Redux. B·∫°n vi·∫øt async tr·ª±c ti·∫øp trong store.

---

### 2. Qu·∫£n l√Ω `loading` ‚Äì `error` ‚Äì `data`

Trong enterprise app, b·∫°n lu√¥n c·∫ßn **3 state ch√≠nh** khi g·ªçi API:

* `loading`: ƒë·ªÉ hi·ªÉn th·ªã spinner/progress.
* `error`: ƒë·ªÉ b√°o l·ªói.
* `data`: state th·ª±c t·∫ø.

N·∫øu kh√¥ng qu·∫£n l√Ω ƒë√∫ng, UI s·∫Ω b·ªã **lag** ho·∫∑c **hi·ªÉn th·ªã sai khi fail**.

---

### 3. Case th·ª±c t·∫ø: CRUD User

V√≠ d·ª• CRUD user v·ªõi Zustand + API JSONPlaceholder.

```ts
// store/userStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'

interface User {
  id: number
  name: string
  email: string
}

interface UserState {
  users: User[]
  loading: boolean
  error: string | null
  fetchUsers: () => Promise<void>
  addUser: (name: string, email: string) => Promise<void>
  deleteUser: (id: number) => Promise<void>
}

export const useUserStore = create<UserState>()(
  devtools((set, get) => ({
    users: [],
    loading: false,
    error: null,

    fetchUsers: async () => {
      set({ loading: true, error: null }, false, 'users/fetch/start')
      try {
        const res = await fetch('https://jsonplaceholder.typicode.com/users')
        if (!res.ok) throw new Error(`API failed: ${res.status}`)
        const data: User[] = await res.json()
        set({ users: data, loading: false }, false, 'users/fetch/success')
      } catch (err: any) {
        set({ error: err.message, loading: false }, false, 'users/fetch/error')
      }
    },

    addUser: async (name, email) => {
      const newUser: User = { id: Date.now(), name, email }
      set((state) => ({ users: [...state.users, newUser] }), false, 'users/add/optimistic')

      try {
        const res = await fetch('https://jsonplaceholder.typicode.com/users', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(newUser),
        })
        if (!res.ok) throw new Error(`POST failed: ${res.status}`)
        const saved = await res.json()
        set(
          (state) => ({
            users: state.users.map((u) => (u.id === newUser.id ? saved : u)),
          }),
          false,
          'users/add/success'
        )
      } catch (err: any) {
        // rollback
        set(
          (state) => ({
            users: state.users.filter((u) => u.id !== newUser.id),
            error: err.message,
          }),
          false,
          'users/add/error'
        )
      }
    },

    deleteUser: async (id) => {
      const prevUsers = get().users
      set((state) => ({ users: state.users.filter((u) => u.id !== id) }), false, 'users/delete/optimistic')

      try {
        const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`, {
          method: 'DELETE',
        })
        if (!res.ok) throw new Error(`DELETE failed: ${res.status}`)
      } catch (err: any) {
        // rollback n·∫øu fail
        set({ users: prevUsers, error: err.message }, false, 'users/delete/error')
      }
    },
  }))
)
```

---

### 4. Khi n√†o d√πng Zustand vs React Query

* ‚úÖ Zustand: UI state, modal, filter, form t·∫°m, optimistic update.
* ‚úÖ React Query: server state, caching, pagination, sync nhi·ªÅu tab, retry, background refresh.

**Enterprise pattern chu·∫©n:**

* **Zustand cho local state (UI logic).**
* **React Query cho server state (data t·ª´ API).**

---

## üíª B√†i t·∫≠p

### Level 1

Vi·∫øt m·ªôt action `updateUser(id, name)` trong store.
üëâ L·ªùi gi·∫£i:

* Optimistic update t√™n user.
* G·ªçi API `PUT`.
* Rollback n·∫øu fail.

### Level 2

Th√™m flag `retry` v√†o `fetchUsers()` (t·ªëi ƒëa 2 l·∫ßn).
üëâ L·ªùi gi·∫£i: s·ª≠ d·ª•ng `for loop` v·ªõi `await fetch`, rollback khi h·∫øt retry.

### Level 3

T·∫°o `searchUsers(query: string)` g·ªçi API `https://jsonplaceholder.typicode.com/users?q=query`.
üëâ L·ªùi gi·∫£i: gi·ªØ `searchResults` trong store ri√™ng, kh√¥ng ƒë·ª•ng `users` ch√≠nh.

---

## ‚ö†Ô∏è Pitfalls

* Kh√¥ng reset `error` ‚Üí UI c·ª© b√°o l·ªói m√£i.
* Kh√¥ng rollback khi fail ‚Üí user th·∫•y d·ªØ li·ªáu ·∫£o.
* Kh√¥ng log action ‚Üí kh√≥ debug khi nhi·ªÅu dev c√πng l√†m.

---

## üìö Further Reading

* Zustand docs: [https://docs.pmnd.rs/zustand](https://docs.pmnd.rs/zustand)
* React Query vs Zustand: [State Management Patterns](https://tkdodo.eu/blog/react-query-as-a-state-manager)
* Optimistic UI t·∫°i scale l·ªõn (Facebook/Twitter pattern).
---


# ‚úÖ Gi·∫£i b√†i t·∫≠p Day 7

## Level 1: `updateUser(id, name)`

**ƒê·ªÅ**: Vi·∫øt m·ªôt action `updateUser(id, name)` trong store.

**L·ªùi gi·∫£i:**

```ts
updateUser: async (id: number, name: string) => {
  const prevUsers = get().users
  const updatedUsers = prevUsers.map((u) =>
    u.id === id ? { ...u, name } : u
  )

  // Optimistic update
  set({ users: updatedUsers }, false, 'users/update/optimistic')

  try {
    const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...prevUsers.find((u) => u.id === id), name }),
    })
    if (!res.ok) throw new Error(`PUT failed: ${res.status}`)
    const saved = await res.json()

    // Replace b·∫±ng d·ªØ li·ªáu t·ª´ API
    set(
      (state) => ({
        users: state.users.map((u) => (u.id === id ? saved : u)),
      }),
      false,
      'users/update/success'
    )
  } catch (err: any) {
    // Rollback n·∫øu fail
    set({ users: prevUsers, error: err.message }, false, 'users/update/error')
  }
}
```

üëâ Best practice: lu√¥n rollback n·∫øu API fail, v√† ƒë·∫∑t t√™n action trong devtools r√µ r√†ng (`users/update/optimistic`, `users/update/success`, `users/update/error`).

---

## Level 2: Retry trong `fetchUsers()`

**ƒê·ªÅ**: Th√™m retry t·ªëi ƒëa 2 l·∫ßn v√†o `fetchUsers()`.

**L·ªùi gi·∫£i:**

```ts
fetchUsers: async () => {
  set({ loading: true, error: null }, false, 'users/fetch/start')
  let attempt = 0
  let success = false
  let lastError: any = null

  while (attempt < 2 && !success) {
    try {
      attempt++
      const res = await fetch('https://jsonplaceholder.typicode.com/users')
      if (!res.ok) throw new Error(`API failed: ${res.status}`)
      const data: User[] = await res.json()
      set({ users: data, loading: false }, false, `users/fetch/success (attempt ${attempt})`)
      success = true
    } catch (err: any) {
      lastError = err
      await new Promise((res) => setTimeout(res, attempt * 1000)) // exponential backoff
    }
  }

  if (!success) {
    set({ error: lastError?.message || 'Unknown error', loading: false }, false, 'users/fetch/error')
  }
}
```

üëâ Best practice: exponential backoff gi√∫p gi·∫£m t·∫£i server, tr√°nh spam request.

---

## Level 3: `searchUsers(query: string)`

**ƒê·ªÅ**: T·∫°o `searchUsers(query)` v√† gi·ªØ k·∫øt qu·∫£ ri√™ng trong `searchResults`.

**L·ªùi gi·∫£i:**

```ts
interface UserState {
  users: User[]
  searchResults: User[]
  loading: boolean
  error: string | null
  // ...
  searchUsers: (query: string) => Promise<void>
}

searchUsers: async (query: string) => {
  set({ loading: true, error: null }, false, 'users/search/start')
  try {
    const res = await fetch(`https://jsonplaceholder.typicode.com/users?q=${query}`)
    if (!res.ok) throw new Error(`Search failed: ${res.status}`)
    const results: User[] = await res.json()
    set({ searchResults: results, loading: false }, false, 'users/search/success')
  } catch (err: any) {
    set({ error: err.message, loading: false }, false, 'users/search/error')
  }
}
```

üëâ Best practice: t√°ch `searchResults` kh·ªèi `users` ƒë·ªÉ tr√°nh l√†m lo·∫°n d·ªØ li·ªáu ch√≠nh.

---

# üéØ Code Challenge Cu·ªëi B√†i (Enterprise)

**ƒê·ªÅ:**
X√¢y d·ª±ng m·ªôt action `bulkDeleteUsers(ids: number[])` xo√° nhi·ªÅu user c√πng l√∫c. Y√™u c·∫ßu:

1. Optimistic update: xo√° ngay trong UI.
2. Th·ª≠ g·ªçi API `DELETE` cho t·ª´ng user.
3. N·∫øu user n√†o xo√° fail ‚Üí rollback l·∫°i ch·ªâ user ƒë√≥.
4. Log k·∫øt qu·∫£ cho t·ª´ng user (success/error).

---

## üí° G·ª£i √Ω t∆∞ duy

* S·ª≠ d·ª•ng `Promise.allSettled` ƒë·ªÉ ch·∫°y song song.
* T√°ch state `users` th√†nh 2 nh√≥m: deleted th√†nh c√¥ng v√† rollback.
* Log c·ª• th·ªÉ `users/delete/success` hay `users/delete/error` cho t·ª´ng ID.

---

## üìù L·ªùi gi·∫£i

```ts
bulkDeleteUsers: async (ids: number[]) => {
  const prevUsers = get().users

  // Optimistic update: remove all ngay l·∫≠p t·ª©c
  set(
    (state) => ({
      users: state.users.filter((u) => !ids.includes(u.id)),
    }),
    false,
    'users/bulkDelete/optimistic'
  )

  const results = await Promise.allSettled(
    ids.map(async (id) => {
      const res = await fetch(`https://jsonplaceholder.typicode.com/users/${id}`, {
        method: 'DELETE',
      })
      if (!res.ok) throw new Error(`DELETE failed: ${res.status}`)
      return id
    })
  )

  const failedIds = results
    .map((r, i) => (r.status === 'rejected' ? ids[i] : null))
    .filter(Boolean) as number[]

  if (failedIds.length > 0) {
    // Rollback ch·ªâ user b·ªã fail
    set(
      (state) => ({
        users: [...state.users, ...prevUsers.filter((u) => failedIds.includes(u.id))],
        error: `Failed to delete users: ${failedIds.join(', ')}`,
      }),
      false,
      'users/bulkDelete/partialRollback'
    )
  }
}
```

---

## ‚úÖ Enterprise best practices r√∫t ra

* Kh√¥ng rollback c·∫£ list n·∫øu ch·ªâ 1‚Äì2 user fail ‚Üí **rollback partial**.
* Log r√µ ID n√†o fail ƒë·ªÉ d·ªÖ debug.
* Optimistic update gi√∫p UI m∆∞·ª£t, user kh√¥ng th·∫•y delay.
* V·ªõi s·ªë l∆∞·ª£ng l·ªõn (1000+ user), c·∫ßn batch API call (paging, chunked requests).

---


# ‚úÖ Day 7 ‚Äì Exercises & Code Challenge (Async Actions + API Calls)

## Exercises

### 1. T·∫°o store qu·∫£n l√Ω danh s√°ch `users`

* State: `users: User[]`, `loading: boolean`, `error: string | null`.
* Action: `fetchUsers`, `addUser`, `deleteUser`.

**Solution (TypeScript + Zustand + async middleware best practices):**

```tsx
// store/userStore.ts
import { create } from "zustand";

type User = { id: number; name: string };

type UserStore = {
  users: User[];
  loading: boolean;
  error: string | null;
  fetchUsers: () => Promise<void>;
  addUser: (user: User) => void;
  deleteUser: (id: number) => void;
};

export const useUserStore = create<UserStore>((set) => ({
  users: [],
  loading: false,
  error: null,

  fetchUsers: async () => {
    set({ loading: true, error: null });
    try {
      const res = await fetch("https://jsonplaceholder.typicode.com/users");
      const data: User[] = await res.json();
      set({ users: data, loading: false });
    } catch (err) {
      set({ error: "Failed to fetch users", loading: false });
    }
  },

  addUser: (user) => set((state) => ({ users: [...state.users, user] })),
  deleteUser: (id) =>
    set((state) => ({ users: state.users.filter((u) => u.id !== id) })),
}));
```

---

### 2. S·ª≠ d·ª•ng trong component

```tsx
import React, { useEffect } from "react";
import { useUserStore } from "../store/userStore";

export default function UserList() {
  const { users, loading, error, fetchUsers } = useUserStore();

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  if (loading) return <p>Loading...</p>;
  if (error) return <p style={{ color: "red" }}>{error}</p>;

  return (
    <ul>
      {users.map((u) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

---

## Code Challenge ‚Äì Enterprise-Ready

### Y√™u c·∫ßu

Vi·∫øt store qu·∫£n l√Ω **auth**:

* `user: User | null`
* `token: string | null`
* `loading, error`
* `login(email, password)` ‚Üí g·ªçi API, l∆∞u token v√†o `localStorage`
* `logout()` ‚Üí xo√° token + reset state
* **Best practices**:

  * Retry 1 l·∫ßn n·∫øu API fail t·∫°m th·ªùi.
  * Log l·ªói ra console.error.
  * Persist token ƒë·ªÉ refresh kh√¥ng b·ªã m·∫•t login.

---

### Solution

```tsx
// store/authStore.ts
import { create } from "zustand";

type User = { id: number; name: string; email: string };

type AuthStore = {
  user: User | null;
  token: string | null;
  loading: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  restoreSession: () => void;
};

export const useAuthStore = create<AuthStore>((set) => ({
  user: null,
  token: null,
  loading: false,
  error: null,

  login: async (email, password) => {
    set({ loading: true, error: null });

    const attempt = async () => {
      const res = await fetch("/api/login", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ email, password }),
      });
      if (!res.ok) throw new Error("Login failed");
      return res.json();
    };

    try {
      const data = await attempt();
      set({ user: data.user, token: data.token, loading: false });
      localStorage.setItem("token", data.token);
    } catch (err) {
      console.error("Login error:", err);
      try {
        const data = await attempt();
        set({ user: data.user, token: data.token, loading: false });
        localStorage.setItem("token", data.token);
      } catch (err2) {
        console.error("Retry login failed:", err2);
        set({ error: "Unable to login", loading: false });
      }
    }
  },

  logout: () => {
    localStorage.removeItem("token");
    set({ user: null, token: null });
  },

  restoreSession: () => {
    const token = localStorage.getItem("token");
    if (token) set({ token });
  },
}));
```

---

### Enterprise Notes

* **Persist session**: d√πng `localStorage`/`cookies` gi√∫p login kh√¥ng b·ªã m·∫•t khi reload.
* **Retry pattern**: th·ª≠ l·∫°i 1 l·∫ßn khi API fail (network drop).
* **Error logging**: lu√¥n log b·∫±ng `console.error` ho·∫∑c logger service (Sentry, Datadog).
* **Scalability**: c√≥ th·ªÉ thay API `/api/login` b·∫±ng Axios instance k√®m interceptors.

---

# üìù Interview Q\&A ‚Äì Async Actions (Zustand)

### 1. Trong Zustand, async actions ƒë∆∞·ª£c vi·∫øt nh∆∞ th·∫ø n√†o?

**Tr·∫£ l·ªùi:**

* Async actions ch·ªâ l√† **h√†m async** trong store.
* Kh√¥ng c·∫ßn middleware nh∆∞ Redux Thunk.
* V√≠ d·ª•:

```ts
fetchUsers: async () => {
  set({ loading: true });
  try {
    const res = await fetch("/api/users");
    set({ users: await res.json(), loading: false });
  } catch (err) {
    set({ error: "Failed", loading: false });
  }
}
```

---

### 2. So s√°nh async actions trong Zustand vs Redux Thunk vs React Query?

**Tr·∫£ l·ªùi:**

* **Zustand**: ƒë∆°n gi·∫£n, kh√¥ng c·∫ßn extra middleware, d·ªÖ code, control ho√†n to√†n logic fetch.
* **Redux Thunk**: c·∫ßn setup middleware, boilerplate nhi·ªÅu (actions, reducers, types).
* **React Query**: chuy√™n cho server state, built-in caching, retry, background refetch.

üëâ Trong enterprise:

* D√πng **Zustand** cho **UI/global state** (auth, modal, theme).
* D√πng **React Query** cho **server state** (data list, caching).
* Tr√°nh bi·∫øn Zustand th√†nh "React Query th·ª© 2".

---

### 3. L√†m sao ƒë·ªÉ tr√°nh race condition khi g·ªçi async nhi·ªÅu l·∫ßn?

**Tr·∫£ l·ªùi:**

* Race condition = request A ch·∫≠m h∆°n request B nh∆∞ng update state sau ‚Üí d·ªØ li·ªáu sai.
* C√°ch gi·∫£i quy·∫øt:

  1. L∆∞u **requestId** ho·∫∑c **timestamp** trong store.
  2. Ch·ªâ update state n·∫øu requestId tr√πng v·ªõi latest.

```ts
let currentReq = 0;

fetchUsers: async () => {
  const reqId = ++currentReq;
  set({ loading: true });
  const res = await fetch("/api/users");
  if (reqId === currentReq) {
    set({ users: await res.json(), loading: false });
  }
}
```

---

### 4. Trong enterprise app, async actions th∆∞·ªùng th√™m g√¨ ngo√†i fetch?

**Tr·∫£ l·ªùi:**

* Retry (network drop).
* Logging (console.error ho·∫∑c Sentry).
* Rollback (optimistic update fail).
* Persist (localStorage, IndexedDB).
* AbortController (hu·ª∑ request khi unmount).

---

### 5. N·∫øu API fail li√™n t·ª•c, b·∫°n handle th·∫ø n√†o trong Zustand?

**Tr·∫£ l·ªùi:**

* Retry c√≥ gi·ªõi h·∫°n (1‚Äì3 l·∫ßn).
* Lu√¥n set `error` trong store ƒë·ªÉ UI hi·ªÉn th·ªã fallback.
* G·ª≠i log t·ªõi monitoring service (Sentry, Datadog).
* Kh√¥ng retry v√¥ h·∫°n ‚Üí tr√°nh DDoS ch√≠nh server c·ªßa m√¨nh.

---


# üöÄ Race Condition + AbortController trong Zustand

## 1. Race Condition Fix

Khi g·ªçi API li√™n t·ª•c (v√≠ d·ª• search box), request c≈© c√≥ th·ªÉ v·ªÅ sau request m·ªõi ‚Üí d·ªØ li·ªáu sai.
Gi·∫£i ph√°p: **requestId** (ho·∫∑c timestamp) ‚Üí ch·ªâ update n·∫øu l√† request m·ªõi nh·∫•t.

```ts
import { create } from "zustand";

interface UserState {
  users: any[];
  loading: boolean;
  error: string | null;
  fetchUsers: () => Promise<void>;
}

let currentReq = 0;

export const useUserStore = create<UserState>((set) => ({
  users: [],
  loading: false,
  error: null,

  fetchUsers: async () => {
    const reqId = ++currentReq; // tƒÉng id m·ªói l·∫ßn g·ªçi
    set({ loading: true, error: null });

    try {
      const res = await fetch("/api/users");
      const data = await res.json();

      if (reqId === currentReq) {
        // ch·ªâ update state n·∫øu l√† request m·ªõi nh·∫•t
        set({ users: data, loading: false });
      }
    } catch (err) {
      if (reqId === currentReq) {
        set({ error: "Failed to fetch users", loading: false });
      }
    }
  },
}));
```

üëâ ƒê√¢y l√† pattern hay d√πng trong enterprise search / typeahead.

---

## 2. AbortController (Hu·ª∑ request khi unmount ho·∫∑c khi c√≥ request m·ªõi)

Khi user spam search, ta hu·ª∑ request c≈© ngay thay v√¨ ƒë·ªÉ server tr·∫£ v·ªÅ mu·ªôn.

```ts
import { create } from "zustand";

interface SearchState {
  results: any[];
  loading: boolean;
  error: string | null;
  search: (query: string) => Promise<void>;
}

let controller: AbortController | null = null;

export const useSearchStore = create<SearchState>((set) => ({
  results: [],
  loading: false,
  error: null,

  search: async (query: string) => {
    // hu·ª∑ request c≈© n·∫øu c√≥
    if (controller) controller.abort();
    controller = new AbortController();

    set({ loading: true, error: null });

    try {
      const res = await fetch(`/api/search?q=${query}`, {
        signal: controller.signal,
      });
      const data = await res.json();
      set({ results: data, loading: false });
    } catch (err: any) {
      if (err.name === "AbortError") {
        console.log("Request cancelled");
        return;
      }
      set({ error: "Search failed", loading: false });
    }
  },
}));
```

üëâ ƒê√¢y l√† pattern chu·∫©n enterprise:

* K·∫øt h·ª£p `AbortController` ƒë·ªÉ cancel request th·ª´a.
* Gi·∫£m load server, tr√°nh UI hi·ªÉn th·ªã k·∫øt qu·∫£ c≈©.

---

üìå T√≥m l·∫°i:

* **Race Condition Fix** = ƒë·∫£m b·∫£o state ch·ªâ update t·ª´ request m·ªõi nh·∫•t.
* **AbortController** = hu·ª∑ request th·ª´a, t·ªëi ∆∞u UX & server load.

---
T·∫°o **Custom Zustand middleware** ƒë·ªÉ t√°i s·ª≠ d·ª•ng cho m·ªçi async action (fetch, search, update).

---

# üõ†Ô∏è Middleware: `withAbortAndRace`

## 1. √ù t∆∞·ªüng

* **Race Condition Fix**: m·ªói l·∫ßn g·ªçi async ‚Üí tƒÉng `requestId`. Ch·ªâ commit state n·∫øu ƒë√∫ng request cu·ªëi.
* **AbortController**: t·ª± ƒë·ªông abort request c≈© khi c√≥ request m·ªõi.

## 2. Middleware Code

```ts
import { StateCreator } from "zustand";

export interface AsyncControllerState {
  _reqId: number;
  _controller: AbortController | null;
}

export function withAbortAndRace<
  T extends object
>(config: StateCreator<T & AsyncControllerState>): StateCreator<T> {
  return (set, get, api) =>
    config(
      (args) => set(args),
      () => get() as T & AsyncControllerState,
      api
    ) as any;
}

// Utility cho async actions
export const asyncAction =
  <T>(fn: (signal: AbortSignal, reqId: number) => Promise<T>) =>
  async (set: any, get: any) => {
    // h·ªßy request c≈©
    if (get()._controller) get()._controller.abort();

    const controller = new AbortController();
    const reqId = get()._reqId + 1;

    set({ _controller: controller, _reqId: reqId });

    try {
      const data = await fn(controller.signal, reqId);
      if (reqId === get()._reqId) return data; // ch·ªâ l·∫•y data t·ª´ request cu·ªëi
    } catch (err: any) {
      if (err.name === "AbortError") return null;
      throw err;
    }
  };
```
* Override l·∫°i `get()` ƒë·ªÉ √©p ki·ªÉu (`as T & AsyncControllerState`).
* Khi ·ªü trong h√†m `asyncAction`, b·∫°n **c·∫ßn d·ªØ li·ªáu hi·ªán t·∫°i** (v√≠ d·ª• `_reqId`, `_controller`).
* N·∫øu b·∫°n d√πng `set()` ·ªü ƒë√≥ ‚Üí b·∫°n ch·ªâ c·∫≠p nh·∫≠t state.
* N·∫øu b·∫°n c·∫ßn ƒë·ªçc state ‚Üí b·∫°n b·∫Øt bu·ªôc ph·∫£i `get().stateKey`.
---

## 3. √Åp d·ª•ng trong Store

```ts
import { create } from "zustand";
import { withAbortAndRace, asyncAction, AsyncControllerState } from "./middleware";

interface SearchState extends AsyncControllerState {
  results: any[];
  loading: boolean;
  error: string | null;
  search: (query: string) => Promise<void>;
}

export const useSearchStore = create<SearchState>()(
  withAbortAndRace((set, get) => ({
    results: [],
    loading: false,
    error: null,
    _reqId: 0,
    _controller: null,

    search: async (query: string) => {
      set({ loading: true, error: null });

      const run = asyncAction(async (signal) => {
        const res = await fetch(`/api/search?q=${query}`, { signal });
        return await res.json();
      });

      try {
        const data = await run(set, get);
        if (data) set({ results: data, loading: false });
      } catch (err) {
        set({ error: "Search failed", loading: false });
      }
    },
  }))
);
```

---

## 4. ∆Øu ƒëi·ªÉm enterprise

* Kh√¥ng l·∫∑p code cho t·ª´ng async action.
* D√πng ƒë∆∞·ª£c cho **search, pagination, filter, API call**.
* An to√†n race condition + ti·∫øt ki·ªám bƒÉng th√¥ng server (abort request th·ª´a).

---

üëâ Gi·ªù m·ªói khi b·∫°n mu·ªën t·∫°o 1 async action trong store, ch·ªâ c·∫ßn wrap b·∫±ng `asyncAction(...)` thay v√¨ vi·∫øt l·∫°i logic race/abort.

---
Vi·∫øt l·∫°i **2 version side-by-side**:

* **Version 1 (Manual)** ‚Üí d·ªÖ hi·ªÉu, code th·∫≥ng trong store.
* **Version 2 (Middleware h√≥a)** ‚Üí g·ªçn g√†ng, t√°i s·ª≠ d·ª•ng ƒë∆∞·ª£c cho nhi·ªÅu store.

---

# üîπ Version 1: Manual Store (code th·∫≥ng trong store)

```ts
import { create } from "zustand";

interface SearchResult {
  id: string;
  name: string;
}

interface SearchState {
  results: SearchResult[];
  loading: boolean;
  error: string | null;

  _reqId: number;
  _controller: AbortController | null;

  search: (query: string) => Promise<void>;
  clear: () => void;
}

export const useSearchStore = create<SearchState>((set, get) => ({
  results: [],
  loading: false,
  error: null,

  _reqId: 0,
  _controller: null,

  search: async (query: string) => {
    if (get()._controller) get()._controller.abort();

    const controller = new AbortController();
    const reqId = get()._reqId + 1;

    set({ _controller: controller, _reqId: reqId, loading: true, error: null });

    try {
      const res = await fetch(`/api/search?q=${encodeURIComponent(query)}`, {
        signal: controller.signal,
      });

      const data: SearchResult[] = await res.json();

      if (reqId === get()._reqId) {
        set({ results: data, loading: false });
      }
    } catch (err: any) {
      if (err.name === "AbortError") return;
      set({ error: err.message || "Search failed", loading: false });
    }
  },

  clear: () => set({ results: [], error: null }),
}));
```

üëâ ∆Øu ƒëi·ªÉm: d·ªÖ ƒë·ªçc, ai m·ªõi h·ªçc c≈©ng hi·ªÉu.
üëâ Nh∆∞·ª£c ƒëi·ªÉm: code l·∫∑p l·∫°i n·∫øu c√≥ nhi·ªÅu store c≈©ng c·∫ßn abort + race.

---

# üîπ Version 2: Middleware h√≥a

## middleware.ts

```ts
import { StateCreator } from "zustand";

export interface AsyncControllerState {
  _reqId: number;
  _controller: AbortController | null;
}

// Middleware ƒë·ªÉ th√™m _reqId + _controller v√†o store
export function withAbortAndRace<T extends object>(
  config: StateCreator<T & AsyncControllerState>
): StateCreator<T> {
  return (set, get, api) =>
    config(
      set,
      () => get() as T & AsyncControllerState,
      api
    ) as any;
}

// Utility: gi√∫p vi·∫øt async action d·ªÖ h∆°n
export const asyncAction =
  <T>(fn: (signal: AbortSignal, reqId: number) => Promise<T>) =>
  async (set: any, get: any) => {
    if (get()._controller) get()._controller.abort();

    const controller = new AbortController();
    const reqId = get()._reqId + 1;

    set({ _controller: controller, _reqId: reqId });

    try {
      const data = await fn(controller.signal, reqId);
      if (reqId === get()._reqId) return data;
    } catch (err: any) {
      if (err.name === "AbortError") return null;
      throw err;
    }
  };
```

## useSearchStore.ts

```ts
import { create } from "zustand";
import {
  withAbortAndRace,
  asyncAction,
  AsyncControllerState,
} from "./middleware";

interface SearchResult {
  id: string;
  name: string;
}

interface SearchState extends AsyncControllerState {
  results: SearchResult[];
  loading: boolean;
  error: string | null;

  search: (query: string) => Promise<void>;
  clear: () => void;
}

export const useSearchStore = create<SearchState>()(
  withAbortAndRace((set, get) => ({
    results: [],
    loading: false,
    error: null,
    _reqId: 0,
    _controller: null,

    search: async (query: string) => {
      set({ loading: true, error: null });

      const run = asyncAction(async (signal) => {
        const res = await fetch(`/api/search?q=${encodeURIComponent(query)}`, {
          signal,
        });
        return await res.json();
      });

      try {
        const data = await run(set, get);
        if (data) set({ results: data, loading: false });
      } catch (err) {
        set({ error: "Search failed", loading: false });
      }
    },

    clear: () => set({ results: [], error: null }),
  }))
);
```

---

# üîë So s√°nh

|                      | Manual Store  | Middleware h√≥a                 |
| -------------------- | ------------- | ------------------------------ |
| D·ªÖ ƒë·ªçc cho ng∆∞·ªùi m·ªõi | ‚úÖ R·∫•t d·ªÖ      | ‚ùå H∆°i kh√≥ hi·ªÉu                 |
| T√°i s·ª≠ d·ª•ng          | ‚ùå Kh√¥ng       | ‚úÖ D·ªÖ d√†ng d√πng cho nhi·ªÅu store |
| D√≤ng code            | üö® L·∫∑p l·∫°i    | ‚ú® G·ªçn h∆°n                      |
| Khi debug            | ‚úÖ D·ªÖ th·∫•y l·ªói | ‚ùå C·∫ßn hi·ªÉu middleware          |

---

üëâ L·ªùi khuy√™n:

* N·∫øu b·∫°n ch·ªâ c√≥ **1-2 store c·∫ßn abort**, d√πng **Manual**.
* N·∫øu app c√≥ nhi·ªÅu store async (search, fetch, filter, pagination‚Ä¶), th√¨ vi·∫øt **middleware** ƒë·ªÉ tr√°nh copy-paste.

---
V√≠ d·ª• **`useUserStore`** ƒë·ªÉ th·∫•y l·ª£i √≠ch c·ªßa middleware `withAbortAndRace` + `asyncAction`.

---

# üîπ useUserStore v·ªõi Middleware

## 1. ƒê·ªãnh nghƒ©a interface

```ts
import { create } from "zustand";
import {
  withAbortAndRace,
  asyncAction,
  AsyncControllerState,
} from "./middleware";

interface User {
  id: string;
  name: string;
  email: string;
}

interface UserState extends AsyncControllerState {
  user: User | null;
  loading: boolean;
  error: string | null;

  fetchUser: (id: string) => Promise<void>;
  clear: () => void;
}
```

---

## 2. Store s·ª≠ d·ª•ng middleware

```ts
export const useUserStore = create<UserState>()(
  withAbortAndRace((set, get) => ({
    user: null,
    loading: false,
    error: null,
    _reqId: 0,
    _controller: null,

    fetchUser: async (id: string) => {
      set({ loading: true, error: null });

      // D√πng asyncAction cho API call
      const run = asyncAction(async (signal) => {
        const res = await fetch(`/api/users/${id}`, { signal });
        if (!res.ok) throw new Error("User not found");
        return await res.json();
      });

      try {
        const data = await run(set, get);
        if (data) set({ user: data, loading: false });
      } catch (err: any) {
        set({ error: err.message, loading: false });
      }
    },

    clear: () => set({ user: null, error: null }),
  }))
);
```

---

# üîπ 3. S·ª≠ d·ª•ng trong Component

```tsx
import React, { useEffect } from "react";
import { useUserStore } from "./store/useUserStore";

export default function UserProfile({ userId }: { userId: string }) {
  const { user, loading, error, fetchUser } = useUserStore();

  useEffect(() => {
    fetchUser(userId);
  }, [userId, fetchUser]);

  if (loading) return <p>Loading user...</p>;
  if (error) return <p style={{ color: "red" }}>{error}</p>;
  if (!user) return <p>No user loaded</p>;

  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

---

# üîë ƒêi·ªÉm m·∫°nh khi t√°i s·ª≠ d·ª•ng middleware

* `useUserStore` v√† `useSearchStore` **kh√¥ng c·∫ßn vi·∫øt l·∫°i logic AbortController / reqId**, ch·ªâ t·∫≠p trung v√†o API ri√™ng c·ªßa ch√∫ng.
* Khi c·∫ßn th√™m store m·ªõi (vd: `usePostsStore`, `useCommentsStore`), b·∫°n ch·ªâ copy v√†i d√≤ng th√¥i.
* Codebase c√¥ng ty l·ªõn s·∫Ω **d·ªÖ maintain** v√† **gi·∫£m bug race condition** khi nhi·ªÅu API call ch·∫°y c√πng l√∫c.

---
Vi·∫øt **`usePostsStore`** v·ªõi h·ªó tr·ª£ **pagination + abort request c≈© + x·ª≠ l√Ω l·ªói**. ƒê√¢y l√† m·ªôt case th·ª±c t·∫ø trong enterprise app (feed, dashboard, blog, social app).

---

# üîπ 1. ƒê·ªãnh nghƒ©a interface

```ts
import { create } from "zustand";
import {
  withAbortAndRace,
  asyncAction,
  AsyncControllerState,
} from "./middleware";

interface Post {
  id: string;
  title: string;
  content: string;
}

interface PostsState extends AsyncControllerState {
  posts: Post[];
  page: number;
  hasMore: boolean;
  loading: boolean;
  error: string | null;

  fetchPosts: (page?: number) => Promise<void>;
  loadMore: () => Promise<void>;
  reset: () => void;
}
```

---

# üîπ 2. Store v·ªõi Middleware

```ts
export const usePostsStore = create<PostsState>()(
  withAbortAndRace((set, get) => ({
    posts: [],
    page: 1,
    hasMore: true,
    loading: false,
    error: null,
    _reqId: 0,
    _controller: null,

    fetchPosts: async (page = 1) => {
      set({ loading: true, error: null });

      const run = asyncAction(async (signal) => {
        const res = await fetch(`/api/posts?page=${page}`, { signal });
        if (!res.ok) throw new Error("Failed to fetch posts");
        return await res.json(); // gi·∫£ s·ª≠ API tr·∫£ { data: Post[], hasMore: boolean }
      });

      try {
        const data = await run(set, get);
        if (data) {
          set({
            posts: page === 1 ? data.data : [...get().posts, ...data.data],
            page,
            hasMore: data.hasMore,
            loading: false,
          });
        }
      } catch (err: any) {
        set({ error: err.message, loading: false });
      }
    },

    loadMore: async () => {
      const { page, hasMore, fetchPosts } = get();
      if (!hasMore || get().loading) return;
      await fetchPosts(page + 1);
    },

    reset: () => set({ posts: [], page: 1, hasMore: true }),
  }))
);
```

---

# üîπ 3. S·ª≠ d·ª•ng trong Component (Pagination UI)

```tsx
import React, { useEffect } from "react";
import { usePostsStore } from "./store/usePostsStore";

export default function PostsList() {
  const { posts, loading, error, fetchPosts, loadMore, hasMore } =
    usePostsStore();

  useEffect(() => {
    fetchPosts(1); // load trang ƒë·∫ßu
  }, [fetchPosts]);

  return (
    <div>
      <h1>üìö Posts</h1>

      {posts.map((p) => (
        <div key={p.id} className="post">
          <h3>{p.title}</h3>
          <p>{p.content}</p>
        </div>
      ))}

      {loading && <p>Loading...</p>}
      {error && <p style={{ color: "red" }}>{error}</p>}

      {hasMore && !loading && (
        <button onClick={loadMore}>Load More</button>
      )}
    </div>
  );
}
```

---

# üîë ƒêi·ªÉm m·∫°nh

* **Race Condition Safe** ‚Üí Khi user b·∫•m "Load More" li√™n t·ª•c, request c≈© s·∫Ω b·ªã h·ªßy.
* **Reusability** ‚Üí Kh√¥ng c·∫ßn vi·∫øt l·∫°i AbortController logic.
* **Scalability** ‚Üí D·ªÖ m·ªü r·ªông cho infinite scroll ho·∫∑c caching.
* **Production Pattern** ‚Üí Gi·ªëng h·ªát app th·∫≠t (social feed, news app, ecommerce).

---

üëâ **`useCommentsStore`** (nested data, ph·ª• thu·ªôc `postId`, c·∫ßn reset khi ƒë·ªïi post). ƒê√¢y s·∫Ω l√† b√†i t·∫≠p n√¢ng cao ƒë·ªÉ hi·ªÉu **state g·∫Øn v·ªõi context ƒë·ªông** (vd: comments c·ªßa t·ª´ng post).

---

# üîπ 1. ƒê·ªãnh nghƒ©a interface

```ts
import { create } from "zustand";
import {
  withAbortAndRace,
  asyncAction,
  AsyncControllerState,
} from "./middleware";

interface Comment {
  id: string;
  postId: string;
  author: string;
  content: string;
}

interface CommentsState extends AsyncControllerState {
  comments: Comment[];
  postId: string | null;
  loading: boolean;
  error: string | null;

  fetchComments: (postId: string) => Promise<void>;
  addComment: (postId: string, content: string) => Promise<void>;
  reset: () => void;
}
```

---

# üîπ 2. Store v·ªõi Middleware

```ts
export const useCommentsStore = create<CommentsState>()(
  withAbortAndRace((set, get) => ({
    comments: [],
    postId: null,
    loading: false,
    error: null,
    _reqId: 0,
    _controller: null,

    fetchComments: async (postId: string) => {
      // n·∫øu ƒë·ªïi sang post kh√°c ‚Üí reset tr∆∞·ªõc
      if (get().postId !== postId) {
        set({ comments: [], postId, error: null });
      }

      set({ loading: true });

      const run = asyncAction(async (signal) => {
        const res = await fetch(`/api/posts/${postId}/comments`, { signal });
        if (!res.ok) throw new Error("Failed to fetch comments");
        return await res.json(); // gi·∫£ s·ª≠ tr·∫£ v·ªÅ Comment[]
      });

      try {
        const data = await run(set, get);
        if (data) set({ comments: data, loading: false });
      } catch (err: any) {
        set({ error: err.message, loading: false });
      }
    },

    addComment: async (postId: string, content: string) => {
      set({ loading: true, error: null });
      try {
        const res = await fetch(`/api/posts/${postId}/comments`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ content }),
        });
        if (!res.ok) throw new Error("Failed to add comment");
        const newComment = await res.json();
        set({ comments: [...get().comments, newComment], loading: false });
      } catch (err: any) {
        set({ error: err.message, loading: false });
      }
    },

    reset: () => set({ comments: [], postId: null, error: null }),
  }))
);
```

---

# üîπ 3. S·ª≠ d·ª•ng trong Component

```tsx
import React, { useEffect } from "react";
import { useCommentsStore } from "./store/useCommentsStore";

export default function Comments({ postId }: { postId: string }) {
  const { comments, loading, error, fetchComments, addComment } =
    useCommentsStore();

  useEffect(() => {
    fetchComments(postId);
  }, [postId, fetchComments]);

  return (
    <div>
      <h2>üí¨ Comments</h2>

      {loading && <p>Loading...</p>}
      {error && <p style={{ color: "red" }}>{error}</p>}

      {comments.map((c) => (
        <div key={c.id} className="comment">
          <strong>{c.author}</strong>: {c.content}
        </div>
      ))}

      <button onClick={() => addComment(postId, "New comment!")}>
        Add Comment
      </button>
    </div>
  );
}
```

---

# üîë ƒêi·ªÉm m·∫°nh

* **G·∫Øn v·ªõi context ƒë·ªông (`postId`)** ‚Üí ƒë·ªïi sang post kh√°c th√¨ comments s·∫Ω reset.
* **Abort request c≈©** ‚Üí n·∫øu user click nhi·ªÅu b√†i vi·∫øt li√™n t·ª•c th√¨ ch·ªâ request cu·ªëi c√πng ƒë∆∞·ª£c gi·ªØ.
* **C√≥ th√™m `addComment`** ‚Üí minh h·ªça CRUD, r·∫•t g·∫ßn th·ª±c t·∫ø enterprise (blog, social app).

---


# üö® Bad vs ‚úÖ Good Practices (Async Store v·ªõi Zustand)

| Ch·ªß ƒë·ªÅ                     | üö® Bad Practice                                              | ‚úÖ Good Practice                                               | Gi·∫£i th√≠ch                                  |                               |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------- | ------------------------------------------- | ----------------------------- |
| **Loading state**          | Kh√¥ng c√≥ `loading` ‚Üí UI kh√¥ng bi·∫øt ƒëang fetch                | Lu√¥n c√≥ `loading: boolean` v√† set ƒë√∫ng l√∫c                    | Gi√∫p UI feedback ngay l·∫≠p t·ª©c               |                               |
| **Error handling**         | Ch·ªâ `console.error` trong catch                              | L∆∞u \`error: string                                           | null\` trong store v√† hi·ªÉn th·ªã UI           | Enterprise y√™u c·∫ßu UX r√µ r√†ng |
| **Race condition**         | Kh√¥ng qu·∫£n l√Ω request ‚Üí data c≈© ghi ƒë√® data m·ªõi              | D√πng `_reqId` + `AbortController`                             | Tr√°nh bug khi user b·∫•m t√¨m ki·∫øm li√™n t·ª•c    |                               |
| **Merge state**            | `set({ comments: data })` ghi ƒë√® to√†n b·ªô                     | `set({ comments: [...get().comments, newComment] })`          | Gi·ªØ state c≈© + th√™m m·ªõi ‚Üí UI m∆∞·ª£t h∆°n       |                               |
| **Reset state**            | Kh√¥ng reset khi context ƒë·ªïi (`postId`, `userId`)             | Reset `comments: []` tr∆∞·ªõc khi fetch m·ªõi                      | Tr√°nh hi·ªÉn th·ªã d·ªØ li·ªáu nh·∫ßm                 |                               |
| **CRUD update**            | Overwrite to√†n b·ªô list khi update/delete                     | Update item b·∫±ng `map`/`filter` theo `id`                     | Tr√°nh flick UI v√† gi·ªØ reference ·ªïn ƒë·ªãnh     |                               |
| **Middleware**             | Kh√¥ng log, kh√¥ng persist                                     | D√πng `persist`, `devtools`, `logger` khi c·∫ßn                  | H·ªó tr·ª£ debug & session management           |                               |
| **Module structure**       | D·ªìn t·∫•t c·∫£ v√†o 1 store kh·ªïng l·ªì                              | Chia nh·ªè: `useAuthStore`, `useUIStore`, `useCommentsStore`    | Enterprise project c·∫ßn maintain d·ªÖ          |                               |
| **Async handling**         | G·ªçi API tr·ª±c ti·∫øp trong component                            | ƒê·∫∑t logic API trong store (action)                            | Gi·∫£m l·∫∑p code, d·ªÖ test & clean architecture |                               |
| **React Query vs Zustand** | L·∫°m d·ª•ng Zustand cho c·∫£ server state l·ªõn (pagination, cache) | D√πng React Query cho server state, Zustand cho UI/local state | Pattern chu·∫©n enterprise                    |                               |

---

# üìå K·∫øt lu·∫≠n

* **Bad** = code ch·∫°y ƒë∆∞·ª£c nh∆∞ng d·ªÖ bug, kh√≥ scale.
* **Good** = code enterprise-ready, d·ªÖ maintain, √≠t bug race condition, ph√π h·ª£p team l·ªõn.
---
**T·ªïng h·ª£p 3 c√°ch ti·∫øp c·∫≠n trong Zustand** ƒë·ªÉ so s√°nh:

---

# üîπ 1. C√°ch d√πng th∆∞·ªùng (Basic Store)

üëâ **C√≥ 3 style** khi g·ªçi `set`:

* **Object tr·ª±c ti·∫øp**
* **Callback prev**
* **K·∫øt h·ª£p v·ªõi `get()`**

```ts
// stores/cart-basic.ts
import { create } from "zustand";

type CartItem = { id: number; name: string; price: number; qty: number };

type CartStore = {
  items: CartItem[];
  addItem: (item: Omit<CartItem, "id" | "qty">) => void;
  removeItem: (id: number) => void;
  getTotal: () => number;
};

export const useCartStore = create<CartStore>((set, get) => ({
  items: [],

  // 1. D√πng object tr·ª±c ti·∫øp
  reset: () => set({ items: [] }),

  // 2. D√πng callback prev
  addItem: (item) =>
    set((prev) => ({
      items: [...prev.items, { ...item, id: Date.now(), qty: 1 }],
    })),

  // 3. D√πng get()
  removeItem: (id) => {
    const prev = get().items;
    set({ items: prev.filter((item) => item.id !== id) });
  },

  getTotal: () => get().items.reduce((sum, i) => sum + i.price * i.qty, 0),
}));
```

‚úÖ **Trade-off**:

* **∆Øu ƒëi·ªÉm**: ƒê∆°n gi·∫£n, nhanh, d·ªÖ hi·ªÉu ‚Üí ph√π h·ª£p d·ª± √°n nh·ªè / MVP.
* **Nh∆∞·ª£c ƒëi·ªÉm**:

  * Kh√¥ng c√≥ logging, persistence, devtools.
  * Code l·∫∑p l·∫°i (v√≠ d·ª• mu·ªën log action th√¨ ph·∫£i th√™m th·ªß c√¥ng).
  * Kh√≥ m·ªü r·ªông khi d·ª± √°n l·ªõn.

---

# üîπ 2. Middleware c√≥ s·∫µn (Built-in)

üëâ Zustand cung c·∫•p middleware nh∆∞: `persist`, `devtools`, `subscribeWithSelector`, `immer`‚Ä¶

V√≠ d·ª• v·ªõi **persist + devtools**:

```ts
// stores/cart-middleware.ts
import { create } from "zustand";
import { persist, devtools } from "zustand/middleware";

type CartItem = { id: number; name: string; price: number; qty: number };
type CartStore = {
  items: CartItem[];
  addItem: (item: Omit<CartItem, "id" | "qty">) => void;
};

export const useCartStore = create<CartStore>()(
  devtools(
    persist(
      (set) => ({
        items: [],
        addItem: (item) =>
          set((prev) => ({
            items: [...prev.items, { ...item, id: Date.now(), qty: 1 }],
          })),
      }),
      { name: "cart-storage" } // save to localStorage
    ),
    { name: "CartStore" }
  )
);
```

‚úÖ **Trade-off**:

* **∆Øu ƒëi·ªÉm**:

  * C√≥ s·∫µn t√≠nh nƒÉng quan tr·ªçng: devtools, persist, logging.
  * Gi·∫£m code l·∫∑p.
* **Nh∆∞·ª£c ƒëi·ªÉm**:

  * TƒÉng dependency ‚Üí n·∫∑ng h∆°n 1 ch√∫t.
  * Middleware c√≥ s·∫µn ch·ªâ gi·∫£i quy·∫øt common case, kh√¥ng linh ho·∫°t cho y√™u c·∫ßu ƒë·∫∑c bi·ªát.

---

# üîπ 3. Custom Middleware

üëâ T·ª± vi·∫øt middleware ƒë·ªÉ m·ªü r·ªông t√≠nh nƒÉng (logging, abort request, race condition, error handling, analytics, ‚Ä¶).

V√≠ d·ª•: custom middleware log m·ªçi action:

```ts
// stores/middleware/logger.ts
import { StateCreator } from "zustand";

export const logger =
  <T extends object>(config: StateCreator<T>): StateCreator<T> =>
  (set, get, api) =>
    config(
      (args) => {
        console.log("[ACTION]", args);
        set(args); // v·∫´n g·ªçi set nh∆∞ b√¨nh th∆∞·ªùng
      },
      get,
      api
    );
```

D√πng trong store:

```ts
// stores/cart-custom.ts
import { create } from "zustand";
import { logger } from "./middleware/logger";

type CartItem = { id: number; name: string; price: number; qty: number };
type CartStore = { items: CartItem[]; addItem: (item: Omit<CartItem, "id" | "qty">) => void };

export const useCartStore = create<CartStore>()(
  logger((set) => ({
    items: [],
    addItem: (item) =>
      set((prev) => ({
        items: [...prev.items, { ...item, id: Date.now(), qty: 1 }],
      })),
  }))
);
```

‚úÖ **Trade-off**:

* **∆Øu ƒëi·ªÉm**:

  * Linh ho·∫°t ‚Üí custom theo nhu c·∫ßu c√¥ng ty.
  * C√≥ th·ªÉ k·∫øt h·ª£p nhi·ªÅu middleware (compose).
  * R·∫•t m·∫°nh trong d·ª± √°n enterprise (abort request, handle cache, retry‚Ä¶).
* **Nh∆∞·ª£c ƒëi·ªÉm**:

  * Ph·ª©c t·∫°p h∆°n, c·∫ßn hi·ªÉu r√µ `set`, `get`, `api`.
  * D·ªÖ sai khi qu·∫£n l√Ω async ho·∫∑c side effect.

---

# üìå T·ªïng h·ª£p so s√°nh

| C√°ch vi·∫øt             | ∆Øu ƒëi·ªÉm                                                              | Nh∆∞·ª£c ƒëi·ªÉm                              | Khi n√†o d√πng                                |
| --------------------- | -------------------------------------------------------------------- | --------------------------------------- | ------------------------------------------- |
| **Th∆∞·ªùng**            | ƒê∆°n gi·∫£n, nhanh, d·ªÖ hi·ªÉu                                             | Kh√¥ng c√≥ devtools, persistence, logging | D·ª± √°n nh·ªè, prototype, POC                   |
| **Middleware c√≥ s·∫µn** | C√≥ devtools, persist, subscribe, immer‚Ä¶ out-of-the-box               | Gi·ªõi h·∫°n t√≠nh nƒÉng, ph·ª• thu·ªôc lib       | D·ª± √°n t·∫ßm trung, c·∫ßn devtools & persistence |
| **Custom Middleware** | Linh ho·∫°t, m·∫°nh m·∫Ω, t√≠ch h·ª£p business logic (abort, retry, logging‚Ä¶) | Ph·ª©c t·∫°p, c·∫ßn hi·ªÉu s√¢u                  | D·ª± √°n l·ªõn, enterprise, nhi·ªÅu logic ƒë·∫∑c th√π  |

---

üëâ T√≥m l·∫°i:

* **Small app**: Basic ƒë·ªß.
* **Medium app**: D√πng middleware built-in (`persist`, `devtools`).
* **Large app / Enterprise**: K·∫øt h·ª£p middleware built-in + custom (cho logging, async race, analytics).


---
üìå [<< Ng√†y 06](./Day06.md) | [Ng√†y 09 >>](./Day09.md)