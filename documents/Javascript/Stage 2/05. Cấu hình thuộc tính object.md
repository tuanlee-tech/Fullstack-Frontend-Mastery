# Cấu hình thuộc tính object
<details>
<summary><strong>1. Thuộc tính writable, enumerable và configurable trong JavaScript</strong></summary>

---

## **1. Ba cờ quan trọng của thuộc tính object**

Mỗi thuộc tính trong object không chỉ là `key-value`, mà còn có các cờ đặc biệt:

| Cờ               | Ý nghĩa                                                                                 |
| ---------------- | --------------------------------------------------------------------------------------- |
| **writable**     | true → giá trị thuộc tính có thể thay đổi. false → read-only.                           |
| **enumerable**   | true → xuất hiện trong vòng lặp `for...in` và `Object.keys`. false → không xuất hiện.   |
| **configurable** | true → có thể xóa hoặc thay đổi các cờ khác. false → không thể thay đổi, không thể xóa. |

* Mặc định, khi tạo object thông thường, tất cả các cờ đều **true**.

---

## **2. Lấy thông tin các cờ**

Sử dụng:

```js
let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
```

Ví dụ:

```js
let user = { name: "Alex" };

let descriptor = Object.getOwnPropertyDescriptor(user, "name");

console.log(JSON.stringify(descriptor, null, 2));
/*
{
  "value": "Alex",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
*/
```

---

## **3. Thay đổi các cờ với `defineProperty`**

```js
Object.defineProperty(obj, propertyName, descriptor);
```

Ví dụ:

```js
let user = {};
Object.defineProperty(user, "name", { value: "Alex" });

let descriptor = Object.getOwnPropertyDescriptor(user, "name");
console.log(JSON.stringify(descriptor, null, 2));
/*
{
  "value": "Alex",
  "writable": false,
  "enumerable": false,
  "configurable": false
}
*/
```

* Lưu ý: Nếu không khai báo cờ, giá trị mặc định là **false**.

---

## **4. Thuộc tính chỉ đọc (non-writable)**

```js
"use strict";

let user = { name: "Alex" };
Object.defineProperty(user, "name", { writable: false });

user.name = "Anna"; 
// Lỗi: Cannot assign to read only property 'name' of object '#<Object>'
```

* Ở chế độ non-strict, việc gán vẫn không thay đổi giá trị, nhưng **không báo lỗi**.

---

## **5. Thuộc tính non-enumerable**

Không xuất hiện trong vòng lặp `for...in` hoặc `Object.keys`:

```js
let user = {
  name: "Alex",
  toString() { return this.name; }
};

Object.defineProperty(user, "toString", { enumerable: false });

for (let key in user) console.log(key); // name
console.log(Object.keys(user)); // ['name']
```

---

## **6. Thuộc tính non-configurable**

Không thể xóa hoặc thay đổi các cờ:

```js
let descriptor = Object.getOwnPropertyDescriptor(Math, "PI");
console.log(JSON.stringify(descriptor, null, 2));
/*
{
  "value": 3.141592653589793,
  "writable": false,
  "enumerable": false,
  "configurable": false
}
*/

Math.PI = 3; // Lỗi: không thể thay đổi
Object.defineProperty(Math, "PI", { writable: true }); // Lỗi
```

* Ngay cả khi `configurable=false`, giá trị vẫn có thể thay đổi nếu `writable=true`.

---

## **7. Tạo non-configurable và non-writable cùng lúc**

```js
"use strict";
let user = { name: "Alex" };

Object.defineProperty(user, "name", {
  writable: false,
  configurable: false
});

user.name = "Anna"; // Lỗi
delete user.name;   // Lỗi
```

---

## **8. Định nghĩa nhiều thuộc tính: `defineProperties`**

```js
Object.defineProperties(user, {
  name: { value: "David", writable: false },
  surname: { value: "Walsh", writable: false }
});
```

---

## **9. Lấy tất cả property descriptor**

```js
Object.getOwnPropertyDescriptors(obj);
```

* Kết hợp `defineProperties` → clone object **bao gồm các cờ**:

```js
let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(user));
```

---

## **10. Các phương thức tiện ích**

| Phương thức                     | Ý nghĩa                                                             |
| ------------------------------- | ------------------------------------------------------------------- |
| `Object.preventExtensions(obj)` | Ngăn không cho thêm thuộc tính mới                                  |
| `Object.seal(obj)`              | Ngăn thêm/xóa thuộc tính (configurable=false)                       |
| `Object.freeze(obj)`            | Ngăn thêm/xóa/thay đổi giá trị (configurable=false, writable=false) |
| `Object.isExtensible(obj)`      | Kiểm tra có thể thêm thuộc tính mới không                           |
| `Object.isSealed(obj)`          | Kiểm tra có bị seal không                                           |
| `Object.isFrozen(obj)`          | Kiểm tra có bị freeze không                                         |

---

</details>
<details>
<summary><strong>2. Getter và Setter trong JavaScript</strong></summary>

---

## **1. Định nghĩa Getter và Setter**

Trong JavaScript, ngoài thuộc tính và phương thức thông thường, object có thể có **getter** và **setter**.

* **Getter (`get`)**: phương thức không có tham số, dùng để **đọc giá trị** như thuộc tính.
* **Setter (`set`)**: phương thức có 1 tham số, dùng để **gán giá trị** như thuộc tính.

Cú pháp:

```js
let obj = {
  // getter
  get propName() {
    // trả về giá trị
  },

  // setter
  set propName(value) {
    // gán giá trị
  }
};
```

---

## **2. Ví dụ cơ bản**

```js
let user = {
  name: "David",
  surname: "Walsh",

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

console.log(user.fullName); // David Walsh
```

* `fullName` được truy cập như **thuộc tính**, mặc dù thực chất là một hàm.

Nếu gán giá trị cho `fullName` mà không có setter:

```js
"use strict";
user.fullName = "Lam Pham"; 
// Lỗi: Cannot set property fullName of #<Object> which has only a getter
```

---

## **3. Thêm Setter**

```js
"use strict";
let user = {
  name: "David",
  surname: "Walsh",
  get fullName() {
    return `${this.name} ${this.surname}`;
  },
  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

user.fullName = "Lam Pham";
console.log(user.fullName); // Lam Pham
```

* Với getter và setter, `fullName` trở thành **thuộc tính ảo**, vẫn truy cập giống thuộc tính bình thường.

---

## **4. Property descriptor cho getter/setter**

Đối với getter/setter:

* **Không có `value` và `writable`**.
* Có:

  * `get`: hàm không tham số.
  * `set`: hàm 1 tham số.
  * `enumerable` và `configurable` giống thuộc tính thông thường.

```js
let user = { name: "David", surname: "Walsh" };

Object.defineProperty(user, "fullName", {
  get() { return `${this.name} ${this.surname}`; },
  set(value) { [this.name, this.surname] = value.split(" "); }
});

console.log(user.fullName); // David Walsh
```

* **Lưu ý:** Một thuộc tính **chỉ là getter/setter hoặc value**, không được tồn tại cùng lúc.

```js
Object.defineProperty({}, "prop", {
  get() { return 0; },
  value: 5
});
// Lỗi: Invalid property descriptor
```

---

## **5. Ứng dụng**

* **Kiểm soát việc gán dữ liệu**:

```js
let user = {
  get name() { return this._name; },
  set name(value) {
    if (value.length < 4) {
      console.log("Tên quá ngắn, tối thiểu 4 chữ cái");
      return;
    }
    this._name = value;
  }
};

user.name = "Alex";
console.log(user.name); // Alex

user.name = ""; // Tên quá ngắn, tối thiểu 4 chữ cái
```

* Giá trị thực lưu trong `_name` (theo quy ước private), truy cập thông qua getter/setter.

---

## **6. Tương thích ngược với code cũ**

Ví dụ: muốn chuyển `age` từ thuộc tính bình thường sang tính toán từ `birthday`:

```js
function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  Object.defineProperty(this, "age", {
    get() {
      let todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
}

let alex = new User("Alex", new Date(1993, 6, 6));
console.log(alex.age); // 29
```

* Code cũ sử dụng `user.age` vẫn chạy bình thường.
* Cho phép chuyển đổi dữ liệu mà không phá vỡ code đang dùng.

---

</details>
