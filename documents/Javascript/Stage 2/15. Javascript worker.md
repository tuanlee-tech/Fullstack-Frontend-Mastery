# Javascript worker
<details>
<summary><strong>1. JavaScript Web Worker API</strong></summary>

### 1. Web Worker là gì?

* JavaScript **chạy đơn luồng**, nghĩa là nếu thực hiện **tác vụ nặng trên main thread**, giao diện web có thể bị **đơ**.
* **Web Worker** là cơ chế cho phép **chạy JavaScript ở background** mà không ảnh hưởng tới giao diện chính.
* Worker và main thread giao tiếp bằng **message**, thông qua `postMessage()` và `onmessage`.

**Lợi ích:** làm trang web mượt mà hơn khi xử lý các tác vụ nặng.

---

### 2. Kiểm tra trình duyệt hỗ trợ Web Worker

```js
if (typeof Worker !== "undefined") {
  console.log("Hỗ trợ Web Worker");
} else {
  console.log("Không hỗ trợ Web Worker");
}
```

---

### 3. Tạo file JavaScript cho Worker

`web_worker.js`

```js
for (var i = 0; i < 10000000000; i++) {
  if (i % 1000000000 === 0) postMessage(i);
}

self.onmessage = function(msg) {
  // Xử lý message từ main thread
};
```

---

### 4. Khởi tạo Web Worker

```js
var w;

function startWorker() {
  if (typeof Worker !== "undefined") {
    if (typeof w === "undefined") {
      w = new Worker("web_worker.js");
    }

    w.onmessage = function(event) {
      console.log("Message from worker:", event.data);
    };

    w.onerror = function(err) {
      console.error("Worker error:", err);
    };
  } else {
    console.log("Trình duyệt không hỗ trợ Web Worker");
  }
}
```

* **`Worker.onmessage`**: nhận message từ worker.
* **`Worker.onerror`**: nhận lỗi từ worker.

---

### 5. Dừng Web Worker

```js
w.terminate(); // Ngừng worker
```

---

### 6. Giao tiếp giữa main thread và worker

#### a) `postMessage()` với dữ liệu thông thường

* **Main thread gửi:**

```js
myWorker.postMessage({ cmd: "start", msg: "hello" });
```

* **Worker nhận:**

```js
self.onmessage = function(event) {
  console.log(event.data.cmd, event.data.msg);
  if(event.data.cmd === "start") {
    // xử lý task
    postMessage({ cmd: "resp", msg: "done" });
  }
};
```

**Nhược điểm:** dữ liệu lớn được **copy**, tốn bộ nhớ.

---

#### b) Sử dụng **Transferable Object**

* Dữ liệu được **chuyển quyền sở hữu**, không copy → tiết kiệm bộ nhớ.

**Main thread:**

```js
var arrBuf = new ArrayBuffer(1000);

myWorker.postMessage({ buf: arrBuf }, [arrBuf]);

console.log(arrBuf.byteLength); // 0 sau khi transfer
```

**Worker:**

```js
self.onmessage = function(event) {
  console.log(event.data.buf.byteLength); // 1000
};
```

* Transferable Object phổ biến: `ArrayBuffer`, `MessagePort`.

---

### 7. Lưu ý

* Message được xử lý **tuần tự**, theo thứ tự gửi.
* Worker có thể **tự đóng** bằng `self.close()`.
* Sử dụng Worker cho các **tác vụ nặng, tính toán lớn**, tránh làm UI đơ.

---

### 8. Tham khảo

* [HTML5 Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
* [Using Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
* [Web Worker Transferable Objects](https://developer.mozilla.org/en-US/docs/Web/API/Transferable)

</details>
<details>
<summary><strong>2. JavaScript Service Worker</strong></summary>

### 1. Service Worker là gì?

* Là một **script chạy ở background**, tách khỏi trang web.
* Không liên kết với một trang cụ thể, **không truy cập DOM**, có thể **dừng khi không cần** và **chỉ chạy khi cần thiết**.
* Chỉ hoạt động trên **HTTPS**.

**Tính năng chính:**

* Giúp **trang web chạy nhanh hơn** và có thể **offline**.
* Xử lý các tác vụ **background**: push notifications, background sync.

---

### 2. Đăng ký Service Worker

**Cấu trúc tệp:**

```
index.html
service_worker.js
main.js
style.css
```

**main.js**

```js
if ("serviceWorker" in navigator) {
  navigator.serviceWorker
    .register("service_worker.js")
    .then(reg => console.log("Registered service worker"))
    .catch(err => console.log("Register failed", err));
}
```

**Lưu ý:**

* File `service_worker.js` quyết định URL mà nó quản lý.
* `.register()` trả về **Promise**.
* Trang web phải **HTTPS** và **same origin**.

---

### 3. Install Service Worker

**service\_worker.js**

```js
const PRECACHE = "my-precache-v1";
const RUNTIME = "my-runtime";
const PRECACHE_URLS = [
  "index.html",
  "./",
  "style.css",
  "main.js"
];

self.addEventListener("install", event => {
  event.waitUntil(
    caches.open(PRECACHE)
      .then(cache => cache.addAll(PRECACHE_URLS))
      .then(self.skipWaiting())
  );
});
```

* Mục đích: lưu **resources cần thiết** vào cache.
* `self.skipWaiting()`: dừng install và chuyển sang bước activate.

---

### 4. Activate Service Worker

```js
self.addEventListener("activate", event => {
  const currentCaches = [PRECACHE, RUNTIME];
  event.waitUntil(
    caches.keys()
      .then(cacheNames => cacheNames.filter(cacheName => !currentCaches.includes(cacheName)))
      .then(cachesToDelete => Promise.all(cachesToDelete.map(cacheToDelete => caches.delete(cacheToDelete))))
      .then(() => self.clients.claim())
  );
});
```

* Xóa **cache cũ** và giữ cache mới.
* `self.clients.claim()`: kích hoạt Service Worker ngay lập tức.

**Cập nhật resources mới:**

* Thay đổi tên PRECACHE → Service Worker sẽ xóa cache cũ.

---

### 5. Fetch Handler

```js
self.addEventListener("fetch", event => {
  if (event.request.url.startsWith(self.location.origin)) {
    event.respondWith(
      caches.match(event.request).then(cachedResponse => {
        if (cachedResponse) return cachedResponse;

        return caches.open(RUNTIME).then(cache =>
          fetch(event.request).then(response => {
            cache.put(event.request, response.clone());
            return response;
          })
        );
      })
    );
  }
});
```

**Ý nghĩa:**

1. Bỏ qua request **cross-origin**.
2. Nếu có **cache**, trả về ngay.
3. Nếu không, fetch từ server, lưu vào **RUNTIME cache**, rồi trả về.

* Service Worker đảm nhận **offline resources** và **định tuyến requests**.

---

### 6. Tổng kết

* **Install & Activate** → lưu resources vào cache.
* **Fetch** → định tuyến và phục vụ offline.
* Service Worker giúp web **nhanh hơn**, **offline**, và **background tasks**.

---

### 7. Tham khảo

* [Service Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
* [Using Service Workers](https://developers.google.com/web/fundamentals/primers/service-workers)
* [Service Workers: an Introduction](https://developers.google.com/web/ilt/pwa/introduction-to-service-worker)

### 8. Câu hỏi 

## **1. Service Worker là gì?**

* **Service Worker (SW)** là một file JavaScript chạy **tách biệt khỏi main thread** của trình duyệt.
* Nó **không can thiệp trực tiếp vào DOM** nhưng có thể lắng nghe các sự kiện mạng (fetch), push notification, background sync,...
* Nhiệm vụ chính:

  1. **Cache dữ liệu & offline** → giúp ứng dụng chạy được khi không có Internet.
  2. **Intercept request** → kiểm soát mạng, có thể trả về dữ liệu cache hoặc fetch từ server.
  3. **Background task** → nhận notification, sync dữ liệu ngầm.

**Lưu ý:** SW chỉ chạy trên **HTTPS** (trừ localhost), vì nó cần bảo mật.

---

## **2. Vòng đời của Service Worker**

Vòng đời của Service Worker khá khác so với JavaScript thông thường, bao gồm **4 giai đoạn chính**: **Register → Install → Activate → Fetch/Idle**.

### **2.1. Register (Đăng ký)**

* SW được **khởi tạo từ web app** bằng `navigator.serviceWorker.register('/sw.js')`.
* Trình duyệt sẽ **tải file SW** và chuẩn bị cài đặt.
* Ví dụ:

```javascript
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then(reg => console.log('Service Worker registered', reg))
    .catch(err => console.log('SW registration failed', err));
}
```

---

### **2.2. Install (Cài đặt)**

* Khi SW được tải, nó bước vào giai đoạn **install**.
* Thường dùng để **cache các tài nguyên tĩnh** (HTML, CSS, JS, images,...)
* Nếu install thất bại (ví dụ cache bị lỗi), SW sẽ không được kích hoạt.
* Ví dụ trong `sw.js`:

```javascript
self.addEventListener('install', event => {
  console.log('Service Worker installing...');
  event.waitUntil(
    caches.open('v1').then(cache => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/app.js'
      ]);
    })
  );
});
```

> `event.waitUntil()`: giữ SW ở trạng thái install cho đến khi promise hoàn tất.

---

### **2.3. Activate (Kích hoạt)**

* Sau khi install thành công, SW bước vào **activate**.
* Giai đoạn này thường dùng để **dọn dẹp cache cũ**, chuẩn bị SW mới quản lý ứng dụng.
* Ví dụ:

```javascript
self.addEventListener('activate', event => {
  console.log('Service Worker activated');
  event.waitUntil(
    caches.keys().then(keys => {
      return Promise.all(
        keys.filter(key => key !== 'v1')
            .map(key => caches.delete(key))
      );
    })
  );
});
```

---

### **2.4. Fetch (Chặn request)**

* SW giờ đã **hoạt động và quản lý mạng**.
* Bất kỳ request từ web page (HTML, API, images...) đều đi qua SW.
* Tại đây có thể trả về dữ liệu từ cache hoặc fetch từ network.
* Ví dụ cache-first strategy:

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request);
    })
  );
});
```

---

### **Tóm tắt vòng đời**

| Giai đoạn      | Mục đích chính                                   |
| -------------- | ------------------------------------------------ |
| **Register**   | Đăng ký SW với trình duyệt                       |
| **Install**    | Cache tài nguyên tĩnh, chuẩn bị offline          |
| **Activate**   | Xóa cache cũ, chuẩn bị SW mới                    |
| **Fetch/Idle** | Chặn request, trả dữ liệu offline, nhận push,... |

---

💡 **Lưu ý quan trọng:**

1. SW **chỉ chạy khi trang được load lần đầu**, không tự động chạy trên tất cả tab.
2. SW **lưu trữ lâu dài**, trình duyệt quản lý version. Khi SW mới xuất hiện, trình duyệt sẽ **install nhưng chưa activate** nếu còn tab cũ đang dùng SW cũ.
3. SW **không có quyền DOM**, nên chỉ thao tác cache, fetch, push, sync,...




</details>
