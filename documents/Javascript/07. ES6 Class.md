# ES6 Class
<details>
<summary><strong>1. Cú pháp cơ bản của class trong JavaScript</strong></summary>

---

## **1. Khái niệm cơ bản**

* **Class** là cú pháp trong ES6 để tạo các object cùng kiểu, thay thế cho hàm khởi tạo + prototype.
* Class trong JS thực chất là **một loại function** với `[[IsClassConstructor]] = true`.

### **Cú pháp cơ bản**

```js
class MyClass {
  constructor(...) { /* khởi tạo thuộc tính */ }
  method1() { ... }
  method2() { ... }
}
```

* `constructor()` tự động được gọi khi `new MyClass()` tạo object.
* Các phương thức không có dấu phẩy giữa chúng.

**Ví dụ:**

```js
class User {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    console.log(this.name);
  }
}

let user = new User("Alex");
user.sayHi(); // Alex
```

---

## **2. Class là function và prototype**

```js
console.log(typeof User); // "function"
console.log(User.prototype.constructor === User); // true
console.log(Object.getOwnPropertyNames(User.prototype)); // ["constructor", "sayHi"]
```

* Các phương thức trong class được lưu trong `User.prototype`.
* Khi gọi phương thức, JS tìm kiếm trong object trước, nếu không có thì tìm trong prototype.

---

## **3. So sánh class với function truyền thống**

```js
function User(name) { this.name = name; }
User.prototype.sayHi = function() { console.log(this.name); }
```

* Class yêu cầu **gọi bằng `new`**, function thường không.
* Phương thức class là **non-enumerable**.
* Code trong class luôn ở **strict mode**.

```js
class User2 { constructor() {} }
User2(); // Lỗi: Class constructor cannot be invoked without 'new'
```

---

## **4. Class expression**

* Class có thể là **expression**, gán cho biến hoặc trả về từ hàm:

```js
let User = class {
  sayHi() { console.log("Hello"); }
};

// Named class expression
let User = class MyClass {
  sayHi() { console.log(MyClass); } // chỉ nhìn thấy trong class
};
```

* Có thể tạo **động class**:

```js
function makeClass(msg) {
  return class {
    sayHi() { console.log(msg); }
  };
}

let User = makeClass("Hello");
new User().sayHi(); // Hello
```

---

## **5. Getter / Setter**

```js
class User {
  constructor(name) { this.name = name; }

  get name() { return this._name; }
  set name(value) {
    if (value.length < 4) alert("Name too short");
    else this._name = value;
  }
}

let user = new User("Alex");
console.log(user.name); // Alex
```

---

## **6. Phương thức với tên động**

```js
class User {
  ["say" + "Hi"]() {
    console.log("Hello");
  }
}
new User().sayHi(); // Hello
```

---

## **7. Thuộc tính trong class**

* Khác phương thức: **thuộc tính tồn tại trên object**, không trên prototype.

```js
class User {
  name = "Alex";
}

let user = new User();
console.log(user.name);           // Alex
console.log(User.prototype.name); // undefined
```

* Thuộc tính có thể gán động:

```js
class User {
  name = prompt("Name?", "Alex");
}
```

---

## **8. Bind `this` trong class**

* Khi truyền phương thức ra ngoài, `this` có thể thay đổi:

```js
class Button {
  constructor(value) { this.value = value; }
  click() { console.log(this.value); }
}

let button = new Button("hello");
setTimeout(button.click, 1000); // undefined
```

**Giải pháp:**

1. **Arrow function khi gọi:**

```js
setTimeout(() => button.click(), 1000);
```

2. **Arrow function trong định nghĩa phương thức:**

```js
class Button {
  click = () => console.log(this.value);
}
```

3. **Bind trong constructor:**

```js
this.click = this.click.bind(this);
```

---

## **9. Tổng kết cú pháp class**

```js
class MyClass {
  prop = value;         // thuộc tính
  constructor(...) {}   // hàm khởi tạo
  method(...) {}        // phương thức
  get something() {}    // getter
  set something() {}    // setter
  [Symbol.iterator]() {} // phương thức với tên động
}
```

* **Class = function** + `[[IsClassConstructor]] = true`
* Phương thức / getter / setter được lưu trong `MyClass.prototype`.
* Thuộc tính tồn tại riêng trên mỗi object tạo từ class.

</details>
<details>
<summary><strong>2. Kế thừa trong JavaScript</strong></summary>

---

## **1. Cú pháp kế thừa**

```js
class Child extends Parent {
  // ...
}
```

* `extends` tạo **mối quan hệ prototype chain**:
  `Child.prototype.[[Prototype]] = Parent.prototype`
* Object từ `Child` có thể dùng **tất cả phương thức từ Parent** nếu không được ghi đè.

**Ví dụ:**

```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    console.log(`${this.name} runs with speed ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    console.log(`${this.name} stands still.`);
  }
}

class Rabbit extends Animal {
  hide() {
    console.log(`${this.name} hides!`);
  }
}

let rabbit = new Rabbit("White Rabbit");

rabbit.run(5);  // White Rabbit runs with speed 5.
rabbit.hide();  // White Rabbit hides!
```

* Khi gọi `rabbit.run()`: JS tìm **trong object → Rabbit.prototype → Animal.prototype**.

---

## **2. Kế thừa từ biểu thức**

* `extends` có thể nhận **một class từ biểu thức hoặc hàm trả về class**:

```js
function f(message) {
  return class {
    sayHi() { console.log(message); }
  };
}

class User extends f("Hello") {}
new User().sayHi(); // Hello
```

---

## **3. Ghi đè phương thức**

* Class con có thể định nghĩa lại phương thức class cha:

```js
class Rabbit extends Animal {
  stop() {
    console.log(`${this.name} stops!`);
  }
}
```

* Nếu muốn **dựa trên phương thức cha**, dùng `super.method()`:

```js
class Rabbit extends Animal {
  stop() {
    super.stop(); // gọi stop của Animal
    console.log(`${this.name} hides after stopping!`);
  }
}
```

* **Arrow function** không có `super`, nhưng tham chiếu đến `super` từ phạm vi bao quanh:

```js
class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // OK
  }
}
```

---

## **4. Ghi đè hàm khởi tạo**

* Nếu không định nghĩa constructor, JS tự sinh:

```js
class Rabbit extends Animal {
  constructor(...args) { super(...args); }
}
```

* Khi định nghĩa constructor mới, **phải gọi `super(...)` trước khi dùng `this`**:

```js
class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name);       // bắt buộc gọi hàm cha trước
    this.earLength = earLength;
  }
}

let rabbit = new Rabbit("White Rabbit", 10);
console.log(rabbit.name);      // White Rabbit
console.log(rabbit.earLength); // 10
```

* Nếu bỏ `super()`, JS sẽ báo lỗi:

```
ReferenceError: Must call super constructor in derived class before accessing 'this'
```

---

## **5. Tổng kết**

* **Cú pháp:** `class Child extends Parent`
* **Nguyên lý:** `Child.prototype.__proto__ = Parent.prototype`
* **Khi tìm phương thức:** JS tìm trong object → Child.prototype → Parent.prototype
* **Constructor ghi đè:** phải gọi `super(...)` trước khi dùng `this`
* **Phương thức ghi đè:** dùng `super.method()` nếu muốn gọi phương thức cha
* **Arrow function** không có `super`, tham chiếu `super` từ scope ngoài

</details>
<details>
<summary><strong>3. Thuộc tính và phương thức static trong JavaScript</strong></summary>

---

## **1. Phương thức static**

* `static` là từ khóa dùng để định nghĩa **phương thức trực tiếp trên class**, không nằm trên prototype của các object.

```js
class User {
  static staticMethod() {
    console.log(this === User);
  }
}

User.staticMethod(); // true
```

* Cách viết tương đương:

```js
class User {}
User.staticMethod = function () {
  console.log(this === User);
};
```

* Giá trị `this` trong phương thức static là **chính class**, không phải object.

---

### **Ví dụ: phương thức so sánh**

```js
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

let articles = [
  new Article("HTML", new Date(2019, 1, 1)),
  new Article("CSS", new Date(2019, 0, 1)),
  new Article("JavaScript", new Date(2019, 11, 1)),
];

articles.sort(Article.compare);
console.log(articles[0].title); // CSS
```

* `Article.compare` không thuộc bất kỳ instance nào, mà thuộc class `Article`.

---

### **Ví dụ: phương thức factory**

```js
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static createTodays() {
    return new this("Today's digest", new Date());
  }
}

let article = Article.createTodays();
console.log(article.title); // Today's digest
```

---

## **2. Thuộc tính static**

* Có thể định nghĩa **thuộc tính trực tiếp trên class**:

```js
class Article {
  static publisher = "Lam P.";
}

console.log(Article.publisher); // Lam P.
```

* Tương đương với gán trực tiếp:

```js
Article.publisher = "Lam P.";
```

---

## **3. Kế thừa static**

* Thuộc tính và phương thức static **có thể kế thừa** khi dùng `extends`:

```js
class Animal {
  static planet = "Earth";
  static compare(a, b) { return a.speed - b.speed; }
}

class Rabbit extends Animal {}

console.log(Rabbit.planet);   // Earth
console.log(Rabbit.compare);  // hàm compare của Animal
```

* Nguyên lý:

```js
Rabbit.__proto__ === Animal       // true, kế thừa static
Rabbit.prototype.__proto__ === Animal.prototype // true, kế thừa phương thức thường
```

---

## **4. Tổng kết**

* `static method` và `static property` tồn tại **trên class**, không nằm trên object.
* Sử dụng cho các **hàm tiện ích**, **factory**, **so sánh**, hoặc **thao tác chung với class**.
* Cú pháp:

```js
class MyClass {
  static property = ...;
  static method() { ... }
}
```

* Có thể gán trực tiếp sau khi định nghĩa class:

```js
MyClass.property = ...;
MyClass.method = ...;
```

* Static có thể kế thừa: `B extends A` → tìm static ở A nếu không tìm thấy ở B.

</details>
<details>
<summary><strong>4. Thuộc tính và phương thức private trong JavaScript</strong></summary>

---

## **1. Tính đóng gói (Encapsulation)**

* Là khả năng **che giấu thông tin bên trong đối tượng**, hạn chế môi trường bên ngoài trực tiếp tác động.
* Trong các ngôn ngữ như Java, C++: dùng `private` / `protected`.
* JavaScript **ES6+** hỗ trợ thuộc tính/method **private** thông qua `#`, còn **protected** được quy ước với `_`.

---

## **2. Protected (quy ước `_`)**

* Thường dùng `_` trước tên thuộc tính/method.
* Cho phép kế thừa nhưng **khuyến nghị không truy cập trực tiếp từ bên ngoài**.
* Ví dụ:

```js
class WaterBottle {
  _waterAmount = 0; // protected
  _volume = 0;      // protected

  get waterAmount() {
    return this._waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) value = 0;
    if (value > this._volume) value = this._volume;
    this._waterAmount = value;
  }

  get volume() {
    return this._volume;
  }

  constructor(volume) {
    this._volume = volume;
  }
}

let wb = new WaterBottle(100);
wb.waterAmount = 50;
console.log(wb.waterAmount); // 50
```

* Cũng có thể viết theo **getter/setter dạng phương thức**:

```js
class WaterBottle {
  _waterAmount = 0;
  constructor(volume) { this._volume = volume; }

  getWaterAmount() { return this._waterAmount; }
  setWaterAmount(value) {
    if(value < 0) value = 0;
    if(value > this._volume) value = this._volume;
    this._waterAmount = value;
  }
}

let wb = new WaterBottle(100);
wb.setWaterAmount(50);
console.log(wb.getWaterAmount()); // 50
```

> Nhược điểm: `_` chỉ là quy ước, vẫn có thể truy cập và thay đổi trực tiếp.

---

## **3. Private (thực sự)**

* ES2020+ hỗ trợ **private class fields/methods** bằng ký tự `#`.
* Không thể truy cập từ bên ngoài class hay class kế thừa.

```js
class WaterBottle {
  #waterAmount = 0;
  #volume = 0;

  constructor(volume) {
    this.#volume = volume;
  }

  get waterAmount() { return this.#waterAmount; }
  set waterAmount(value) {
    if(value < 0) value = 0;
    if(value > this.#volume) value = this.#volume;
    this.#waterAmount = value;
  }

  get volume() { return this.#volume; }
}

let wb = new WaterBottle(100);
console.log(wb.waterAmount); // 0
wb.waterAmount = 50;
console.log(wb.waterAmount); // 50
console.log(wb.#volume); // ❌ Lỗi: Private field '#volume' must be declared in an enclosing class
```

* **Lưu ý:**

  * Không thể truy cập thông qua `this[name]`.
  * Private không thể truy cập từ **class kế thừa**.

```js
class ExtendedBottle extends WaterBottle {
  debug() {
    console.log(this.#volume); // ❌ Lỗi
  }
}
```

---

## **4. So sánh Protected vs Private**

| Tính chất          | Protected (`_`)                | Private (`#`)         |
| ------------------ | ------------------------------ | --------------------- |
| Truy cập bên ngoài | Có thể nhưng không khuyến nghị | Không thể             |
| Truy cập class con | Có thể                         | Không thể             |
| Thực thi           | Quy ước                        | Thực sự bởi engine JS |

---

## **5. Tổng kết**

* **Encapsulation** giúp tách biệt **phần triển khai bên trong** với **phần sử dụng bên ngoài**.

* Trong JavaScript:

  1. **Protected**: `_property` hoặc `_method` (quy ước).
  2. **Private**: `#property` hoặc `#method` (thực sự, ES2020+).

* Sử dụng để:

  * Kiểm soát giá trị các thuộc tính.
  * Giữ invariant (bất biến logic) của đối tượng.
  * Ngăn người dùng ngoài thay đổi trực tiếp.

</details>
<details>
<summary><strong>5. Kế thừa built-in class trong JavaScript</strong></summary>

---

## **1. Khái niệm**

* **Built-in class**: các class do JavaScript cung cấp sẵn như `Array`, `Map`, `Set`, `Date`, `Error`,…
* Bạn có thể kế thừa chúng bằng `extends` để thêm tính năng riêng mà vẫn giữ nguyên hành vi gốc.

---

## **2. Ví dụ kế thừa Array**

```js
class MyArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new MyArray(1, 2, 5, 3, 4);
console.log(arr.isEmpty()); // false

// filter trả về cùng kiểu MyArray
let filteredArr = arr.filter((item) => item >= 3);
console.log(filteredArr);        // MyArray [5, 3, 4]
console.log(filteredArr.isEmpty()); // false
```

* **Chú ý:** các phương thức như `filter`, `map`, `slice` sẽ **tạo ra đối tượng cùng kiểu** với constructor của instance (`arr.constructor`).

```js
console.log(arr.constructor); // MyArray
```

---

## **3. Tùy biến kiểu trả về với `Symbol.species`**

* Bạn có thể chỉ định kiểu đối tượng trả về cho các phương thức built-in như `filter`, `map`:

```js
class MyArray extends Array {
  isEmpty() { return this.length === 0; }

  static get [Symbol.species]() {
    return Array; // kết quả trả về sẽ là Array, không phải MyArray
  }
}

let arr = new MyArray(1, 2, 5, 3, 4);
let filteredArr = arr.filter((item) => item >= 3);

console.log(filteredArr);        // Array [5, 3, 4]
console.log(filteredArr.isEmpty); // undefined ❌
```

* Khi dùng `Symbol.species`, đối tượng trả về **không còn kế thừa tính năng của class con** nữa.

---

## **4. Static không được kế thừa từ built-in classes**

* Thông thường, static method được kế thừa giữa các class bình thường.
* **Nhưng với built-in classes thì không.**

Ví dụ:

```js
console.log(Object.keys); // ƒ keys() { [native code] }
console.log(Array.keys);  // undefined
```

* Nguyên nhân: **Array.prototype kế thừa Object.prototype**, nhưng **Array** không kế thừa Object.
  Kiểu inheritance chain khác so với class thường:

```js
console.log(Date.__proto__.__proto__ === Object.prototype); // true
```

* Vì vậy, static của built-in class **không tự động kế thừa**.

---

## **5. Tổng kết**

1. Có thể kế thừa built-in class bằng `class MyClass extends Array { ... }`.
2. Các phương thức tạo ra đối tượng mới (`filter`, `map`) mặc định trả về cùng kiểu class.
3. Dùng `Symbol.species` để tùy chỉnh kiểu trả về.
4. Static method của built-in class **không kế thừa** như class bình thường.
5. Kế thừa built-in class **giữ nguyên prototype chain** nhưng có một số khác biệt về static và constructor.

</details>
