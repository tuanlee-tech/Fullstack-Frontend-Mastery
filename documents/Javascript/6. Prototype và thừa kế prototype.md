# Prototype và thừa kế prototype

<details>
<summary><strong>1. Prototype trong JavaScript</strong></summary>

---

## **1. Khái niệm**

* Mỗi object trong JavaScript có thuộc tính **ẩn `[[Prototype]]`**, giá trị có thể là **null** hoặc **object**.
* Object này gọi là **prototype**.
* Khi truy cập một thuộc tính mà object không có, JavaScript sẽ tự động tìm kiếm trong **prototype** (kế thừa prototype).

---

## **2. Cách sử dụng prototype**

Ví dụ:

```js
let animal = { eats: true };
let rabbit = { jumps: true };

// gán prototype
rabbit.__proto__ = animal;

console.log(rabbit.eats); // true
console.log(rabbit.jumps); // true
```

* `animal` là prototype của `rabbit`.
* Nếu `rabbit` không có thuộc tính, JavaScript sẽ tìm trong `animal`.

---

### **2.1. Kế thừa phương thức**

```js
let animal = {
  eats: true,
  walk() { console.log("Animal walk"); }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

rabbit.walk(); // Animal walk
```

* Prototype có thể móc nối nhiều object:

```js
let longEar = { earLength: 10, __proto__: rabbit };
longEar.walk(); // Animal walk
console.log(longEar.jumps); // true
```

---

## **3. Giới hạn của prototype**

1. **Không được tạo vòng lặp**:

```js
rabbit.__proto__ = animal;
animal.__proto__ = rabbit; // Lỗi: Cyclic __proto__ value
```

2. ****proto** chỉ nhận null hoặc object**:

```js
let rabbit = { jumps: true, __proto__: 1 }; // bị bỏ qua
```

3. **Không thay đổi giá trị trực tiếp**:

```js
rabbit.walk = function() { console.log("Rabbit walk"); };
rabbit.walk(); // Rabbit walk
animal.walk(); // Animal walk
```

* `__proto__` chỉ là **getter/setter** cho `[[Prototype]]`.
* Nên dùng:

  * `Object.getPrototypeOf(obj)`
  * `Object.setPrototypeOf(obj, proto)`

---

## **4. Giá trị this khi kế thừa prototype**

```js
let animal = {
  sleep() { this.isSleeping = true; }
};

let rabbit = { name: "White Rabbit", __proto__: animal };

rabbit.sleep();
console.log(rabbit.isSleeping); // true
console.log(animal.isSleeping); // undefined
```

* `this` tham chiếu tới **đối tượng gọi phương thức**, không phải prototype.

---

## **5. Vòng lặp for...in và prototype**

* `for...in` lặp qua **thuộc tính bản thân** + **thuộc tính prototype**:

```js
let animal = { eats: true };
let rabbit = { jumps: true, __proto__: animal };

for (let prop in rabbit) console.log(prop);
// jumps
// eats
```

* Chỉ duyệt thuộc tính bản thân:

```js
console.log(Object.keys(rabbit)); // ['jumps']
```

* Hoặc kiểm tra:

```js
for (let prop in rabbit) {
  if (rabbit.hasOwnProperty(prop)) console.log(`Our: ${prop}`);
  else console.log(`Inherited: ${prop}`);
}
// Our: jumps
// Inherited: eats
```

> `hasOwnProperty` kế thừa từ `Object.prototype` và **không enumerable**.

---

## **6. Thực hành**

### Bài 1

```js
let animal = { jumps: null };
let rabbit = { __proto__: animal, jumps: true };

console.log(rabbit.jumps); // true
delete rabbit.jumps;
console.log(rabbit.jumps); // null
delete animal.jumps;
console.log(rabbit.jumps); // undefined
```

### Bài 2

```js
let head = { glasses: 1 };
let table = { pen: 3, __proto__: head };
let bed = { sheet: 1, pillow: 2, __proto__: table };
let pockets = { money: 2000, __proto__: bed };
```

* Tìm kiếm theo thứ tự: pockets → bed → table → head

### Bài 3

```js
let animal = { eat() { this.full = true; } };
let rabbit = { __proto__: animal };

rabbit.eat();
console.log(rabbit.full); // true
```

* `this` là `rabbit`, nên `full` được gán vào `rabbit`.

---

## **7. Tổng kết**

* Mỗi object có **`[[Prototype]]`**.
* `__proto__` chỉ là getter/setter của `[[Prototype]]`.
* Truy cập thuộc tính không có → tìm trong prototype.
* Prototype **chỉ hỗ trợ đọc**, không thay đổi trực tiếp.
* `this` luôn tham chiếu **đối tượng gọi phương thức**.
* `for...in` lặp qua thuộc tính **bản thân + prototype**.

</details>
<details>
<summary><strong>2. F.prototype trong JavaScript</strong></summary>

---

## **1. Khái niệm**

* Mỗi hàm trong JavaScript đều có thuộc tính **`prototype`**, dùng để gán **`[[Prototype]]`** cho các object được tạo bởi `new`.
* Ví dụ:

```js
let animal = { eats: true };

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("White Rabbit");
console.log(rabbit.__proto__ === animal); // true
console.log(rabbit.eats); // true
```

* Khi gọi `new Rabbit()`, object `rabbit` sẽ có `[[Prototype]]` là giá trị của `Rabbit.prototype` tại thời điểm gọi.

---

## **2. Thay đổi F.prototype**

* Thay đổi `Rabbit.prototype` **sau khi tạo object** không ảnh hưởng đến object cũ:

```js
Rabbit.prototype = { legs: 4 };

console.log(rabbit.eats); // true
console.log(rabbit.legs); // undefined
```

* `F.prototype` chỉ được dùng tại **thời điểm gọi `new F()`**.

---

## **3. Giá trị mặc định của prototype**

* Mỗi hàm có prototype mặc định:

```js
function Rabbit() {}

/*
  Rabbit.prototype = { constructor: Rabbit }
*/
console.log(Rabbit.prototype.constructor === Rabbit); // true
```

* Các object tạo bởi `new Rabbit()` kế thừa `constructor`:

```js
let rabbit = new Rabbit();
let rabbit2 = new rabbit.constructor("Another Rabbit");
```

* Lưu ý: `constructor` có thể bị mất nếu bạn gán `prototype` bằng object mới:

```js
function Rabbit() {}
Rabbit.prototype = { jumps: true };

let rabbit = new Rabbit();
console.log(rabbit.constructor === Rabbit); // false
```

* Giữ `constructor` mặc định:

```js
Rabbit.prototype.jumps = true;
// hoặc
Rabbit.prototype = { jumps: true, constructor: Rabbit };
```

---

## **4. Lưu ý**

* `F.prototype` chỉ có ý nghĩa khi **gọi `new F()`**.
* Trong object thông thường, `prototype` chỉ là một thuộc tính bình thường:

```js
let user = { name: "Alex", prototype: "abc" };
```

* Giá trị của `F.prototype` **phải là object hoặc null**; các giá trị khác bị bỏ qua.
* `constructor` cho phép truy cập lại hàm khởi tạo của object.

---

## **5. Tổng kết**

| Điểm chính                 | Mô tả                                                           |
| -------------------------- | --------------------------------------------------------------- |
| `F.prototype`              | Thuộc tính mặc định của hàm, dùng gán `[[Prototype]]` khi `new` |
| Chỉ dùng khi gọi `new F()` | Object cũ không bị ảnh hưởng khi `F.prototype` thay đổi         |
| Giá trị mặc định           | Object `{ constructor: F }`                                     |
| `constructor`              | Trỏ về hàm tạo, hữu ích khi cần tạo object mới từ object đã có  |
| Giữ constructor            | Thêm thuộc tính mới vào prototype hoặc gán lại `constructor`    |

</details>
<details>
<summary><strong>3. Native Prototype trong JavaScript</strong></summary>

---

## **1. Khái niệm**

* **Native prototypes** là các prototype gốc của các hàm khởi tạo có sẵn trong JavaScript như: `Object`, `Array`, `Function`, `Date`, `String`, `Number`, `Boolean`.
* Khi tạo object từ các hàm này, object sẽ kế thừa các phương thức từ prototype tương ứng.

### **Ví dụ Object.prototype**

```js
let obj = {};
console.log(obj.__proto__ === Object.prototype); // true
console.log(obj.toString === Object.prototype.toString); // true
console.log(Object.prototype.__proto__); // null
```

* `obj.toString()` được tìm thấy từ `Object.prototype` vì `obj` không có thuộc tính `toString`.

---

## **2. Native prototypes của các kiểu khác**

```js
let arr = [1, 2, 3];
console.log(arr.__proto__ === Array.prototype); // true
console.log(arr.__proto__.__proto__ === Object.prototype); // true
console.log(arr.__proto__.__proto__.__proto__); // null
```

* `Array.prototype` có phương thức riêng như `forEach`, `map`, `filter`.
* Khi có cùng tên phương thức giữa các prototype, **prototype gần hơn với object sẽ được dùng**:

```js
let arr = [1,2,3];
alert(arr); // 1,2,3 <- dùng Array.prototype.toString
```

---

## **3. Kiểu dữ liệu nguyên thủy**

* Khi truy cập phương thức trên kiểu nguyên thủy (`string`, `number`, `boolean`), JavaScript tự động tạo **wrapper object** từ `String`, `Number`, `Boolean`.
* Hai kiểu `null` và `undefined` không có wrapper, do đó không có phương thức nào đi kèm.

---

## **4. Thay đổi native prototypes**

* Có thể thêm phương thức mới cho native prototype:

```js
String.prototype.show = function() {
  console.log(this);
};

"AHA".show(); // AHA!
```

* **Không khuyến khích** thay đổi prototype toàn cục vì có thể gây xung đột giữa các thư viện.
* Chỉ thêm phương thức nếu làm **polyfill**:

```js
if (!String.prototype.repeat) {
  String.prototype.repeat = function(n) {
    return new Array(n + 1).join(this);
  };
}
console.log("Ha".repeat(3)); // HaHaHa
```

---

## **5. Mượn phương thức từ prototype**

* Có thể "mượn" các phương thức từ prototype của object khác:

```js
let obj = { 0: "Hello", 1: "world!", length: 2 };
obj.join = Array.prototype.join;
console.log(obj.join(",")); // Hello,world!
```

* Hoặc gán prototype trực tiếp:

```js
obj.__proto__ = Array.prototype;
console.log(obj.join(",")); // Hello,world!
```

> Lưu ý: chỉ kế thừa một prototype tại một thời điểm.

---

## **6. Thực hành**

### Bài 1: Thêm `defer(ms)` cho tất cả hàm

```js
Function.prototype.defer = function(ms) {
  setTimeout(this, ms);
};

function f() { console.log("Hello!"); }
f.defer(1000); // Hiển thị "Hello!" sau 1 giây
```

### Bài 2: `defer(ms)` trả về wrapper function với tham số

```js
Function.prototype.defer = function(ms) {
  let f = this;
  return function(...args) {
    setTimeout(() => f.apply(this, args), ms);
  };
};

function f(a, b) { console.log(a + b); }
f.defer(1000)(1, 2); // Hiển thị 3 sau 1 giây
```

---

## **7. Tổng kết**

| Khía cạnh          | Mô tả                                                                                          |
| ------------------ | ---------------------------------------------------------------------------------------------- |
| Native prototypes  | Prototype gốc của các hàm khởi tạo sẵn: Object, Array, Function, Date, String, Number, Boolean |
| Phương thức        | Được lưu trong prototype, object chỉ lưu dữ liệu                                               |
| Wrapper object     | Được tạo cho kiểu nguyên thủy để truy cập phương thức                                          |
| Thay đổi prototype | Có thể nhưng **không khuyến khích**, chỉ dùng cho polyfill                                     |
| Mượn phương thức   | Có thể gán trực tiếp hoặc dùng `apply`/`call`                                                  |

</details>
<details>
<summary><strong>4. Các phương thức với prototype trong JavaScript</strong></summary>

---

## **1. Các phương thức chính liên quan đến prototype**

| Phương thức                           | Mô tả                                                                                                                                               |
| ------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| `Object.create(proto, [descriptors])` | Tạo một object mới với `[[Prototype]]` là `proto`. `descriptors` là đối tượng mô tả thuộc tính (writable, enumerable, configurable, getter/setter). |
| `Object.getPrototypeOf(obj)`          | Trả về `[[Prototype]]` của object.                                                                                                                  |
| `Object.setPrototypeOf(obj, proto)`   | Gán `[[Prototype]]` mới cho object.                                                                                                                 |

### **Ví dụ sử dụng:**

```js
let animal = { eats: true };

// tạo object với prototype là animal
let rabbit = Object.create(animal);
console.log(rabbit.eats); // true

console.log(Object.getPrototypeOf(rabbit) === animal); // true

Object.setPrototypeOf(rabbit, {});
console.log(rabbit.eats); // undefined
```

* `Object.create` còn có thể dùng để clone object đầy đủ:

```js
let clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

---

## **2. Object thuần và `__proto__`**

* `__proto__` là **getter/setter của `[[Prototype]]`**, không phải key bình thường.
* Nếu muốn dùng "**proto**" làm key bình thường, có thể:

1. **Sử dụng `Map`**

```js
let obj = new Map();
obj.set("__proto__", "some value");
console.log(obj.get("__proto__")); // "some value"
```

2. **Object không có prototype**

```js
let obj = Object.create(null);
obj["__proto__"] = "some value";
console.log(obj["__proto__"]); // "some value"
```

---

## **3. Một số phương thức hữu ích khác**

| Phương thức                         | Mô tả                                                      |
| ----------------------------------- | ---------------------------------------------------------- |
| `Object.keys(obj)`                  | Trả về mảng các key enumerable (string)                    |
| `Object.values(obj)`                | Trả về mảng các value enumerable                           |
| `Object.entries(obj)`               | Trả về mảng các cặp `[key, value]`                         |
| `Object.getOwnPropertySymbols(obj)` | Trả về mảng key kiểu Symbol                                |
| `Object.getOwnPropertyNames(obj)`   | Trả về mảng key kiểu string, bao gồm non-enumerable        |
| `Reflect.ownKeys(obj)`              | Trả về tất cả key trong object                             |
| `obj.hasOwnProperty(key)`           | Kiểm tra key thuộc về object trực tiếp, không phải kế thừa |

---

## **4. Thực hành**

### Bài 1: Thêm `toString` cho object không có prototype

```js
let dictionary = Object.create(null);

Object.defineProperty(dictionary, "toString", {
  value: function() {
    return Object.keys(this).join(",");
  },
  enumerable: false
});

dictionary.apple = "Apple";
dictionary.__proto__ = "test"; // bình thường, không bị getter/setter
console.log(dictionary.toString()); // "apple,__proto__"
```

* Vòng lặp `for...in` chỉ in `"apple"` và `"__proto__"`, vì `toString` không enumerable.

---

### Bài 2: Giá trị `this` trong các cách gọi phương thức

```js
function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  console.log(this.name);
};

let rabbit = new Rabbit("Rabbit");

// Các cách gọi
rabbit.sayHi();                     // "Rabbit" (this = rabbit)
Rabbit.prototype.sayHi();           // undefined (this = Rabbit.prototype)
Object.getPrototypeOf(rabbit).sayHi(); // undefined (this = Rabbit.prototype)
rabbit.__proto__.sayHi();           // undefined (this = Rabbit.prototype)
```

* Chỉ khi object đứng trước dấu `.` thì `this` sẽ trỏ tới object đó.

---

## **5. Tổng kết**

1. Dùng `Object.getPrototypeOf` và `Object.setPrototypeOf` thay vì `__proto__`.
2. `Object.create` tạo object với prototype tùy chỉnh, đồng thời có thể clone object đầy đủ.
3. `__proto__` là getter/setter, không nên dùng làm key bình thường; dùng `Map` hoặc `Object.create(null)` thay thế.
4. Khi gọi phương thức, giá trị `this` phụ thuộc vào object đứng trước dấu `.`.
5. Các phương thức `Object.keys`, `Object.values`, `Object.entries`, `Object.getOwnPropertyNames/Symbols`, `Reflect.ownKeys` giúp truy xuất key-value object đầy đủ.

</details>
