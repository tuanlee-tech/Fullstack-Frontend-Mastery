
Phần này là **mục lục tổng quan của chuyên mục “Guides”** — nó tương đương với “Sổ tay hướng dẫn chuyên sâu”, mở rộng từ phần *Getting Started*.
Dưới đây là bản dịch tiếng Việt chuẩn, rõ ràng, thống nhất về thuật ngữ và phong cách với 17 phần trước:

---

# 📘 **Guides — Hướng dẫn chuyên sâu**

Phần **Guides** cung cấp các hướng dẫn chi tiết để giúp bạn **vận hành, tối ưu và mở rộng** ứng dụng Next.js trong môi trường thực tế.
Nếu phần **Getting Started** giúp bạn bắt đầu, thì **Guides** sẽ giúp bạn làm chủ toàn bộ hệ sinh thái Next.js.

---

### 🔹 **Danh mục tổng quan**

| Chủ đề                                    | Mô tả                                                                                                  |
| ----------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| **1. Analytics**                             | Đo lường và theo dõi hiệu suất trang bằng **Next.js Speed Insights**.                                  |
| **2. Authentication**                        | Tìm hiểu cách triển khai **xác thực người dùng** trong ứng dụng Next.js.                               |
| **3. Backend for Frontend**                  | Học cách sử dụng Next.js như một **framework backend**.                                                |
| **4. Caching**                               | Tổng quan về **cơ chế bộ nhớ đệm (cache)** trong Next.js.                                              |
| **5. CI Build Caching**                      | Cấu hình **hệ thống CI** để lưu trữ và tái sử dụng cache build của Next.js.                            |
| **6. Content Security Policy (CSP)**         | Thiết lập **Chính sách bảo mật nội dung (CSP)** cho ứng dụng Next.js.                                  |
| **7. CSS-in-JS**                             | Sử dụng các thư viện **CSS-in-JS** cùng Next.js.                                                       |
| **8. Custom Server**                         | Khởi chạy ứng dụng Next.js **bằng server tùy chỉnh** (custom server).                                  |
| **9. Data Security**                         | Tìm hiểu các **tính năng bảo mật dữ liệu** tích hợp trong Next.js và cách bảo vệ dữ liệu ứng dụng.     |
| **10. Debugging**                             | Học cách **debug ứng dụng Next.js** bằng VS Code, Chrome DevTools hoặc Firefox DevTools.               |
| **11. Draft Mode**                            | Sử dụng **draft mode** để chuyển đổi giữa **trang tĩnh và trang động** trong App Router.               |
| **12. Environment Variables**                 | Thêm và truy cập **biến môi trường** trong ứng dụng Next.js.                                           |
| **13. Forms**                                 | Tạo **biểu mẫu (forms)** với **React Server Actions**.                                                 |
| **14. ISR (Incremental Static Regeneration)** | Tạo hoặc cập nhật **trang tĩnh động (ISR)** ngay trong runtime.                                        |
| **15. Instrumentation**                       | Chạy **đo lường và logic khởi động server** bằng instrumentation hooks trong Next.js.                  |
| **16. Internationalization (i18n)**           | Thêm **đa ngôn ngữ** và **định tuyến quốc tế hóa** cho ứng dụng.                                       |
| **17. JSON-LD**                               | Thêm **dữ liệu có cấu trúc (JSON-LD)** để giúp công cụ tìm kiếm và AI hiểu nội dung trang.             |
| **18. Lazy Loading**                          | Tối ưu hiệu suất bằng cách **tải chậm (lazy load)** thư viện và component React.                       |
| **19. Development Environment**               | Tối ưu **môi trường phát triển cục bộ** cho Next.js.                                                   |
| **20. MDX**                                   | Cấu hình và sử dụng **MDX** trong ứng dụng Next.js.                                                    |
| **21. Memory Usage**                          | Tối ưu **bộ nhớ** trong quá trình phát triển và sản xuất.                                              |
| **22. Migrating**                             | Hướng dẫn **chuyển đổi (migrate)** từ framework khác sang Next.js.                                     |
| **23. Multi-tenant**                          | Xây dựng **ứng dụng đa tenant (nhiều không gian người dùng)** với App Router.                          |
| **24. Multi-zones**                           | Xây dựng **micro-frontend** bằng **Multi-Zones**, cho phép deploy nhiều app Next.js trên cùng domain.  |
| **25. OpenTelemetry**                         | Tích hợp **OpenTelemetry** để theo dõi, đo lường và quan sát ứng dụng Next.js.                         |
| **26. Package Bundling**                      | Tối ưu **bundle server và client** để giảm kích thước và tăng hiệu suất.                               |
| **27. Prefetching**                           | Cấu hình **prefetching** trong Next.js để tăng tốc điều hướng trang.                                   |
| **28. Production**                            | Các khuyến nghị để đạt **hiệu suất và trải nghiệm người dùng tốt nhất** khi đưa ứng dụng vào sản xuất. |
| **29. PWAs**                                  | Xây dựng **Progressive Web App (PWA)** với Next.js.                                                    |
| **30. Redirecting**                           | Các cách khác nhau để **xử lý chuyển hướng (redirect)** trong Next.js.                                 |
| **31. Sass**                                  | Dùng **Sass/SCSS** để tạo style cho ứng dụng.                                                          |
| **32. Scripts**                               | Tối ưu **script bên thứ ba (3rd-party)** bằng component tích hợp `next/script`.                        |
| **33. Self-Hosting**                          | Học cách **tự host** ứng dụng Next.js trên Node.js, Docker hoặc static HTML.                           |
| **34. SPAs**                                  | Tìm hiểu cách Next.js hỗ trợ xây dựng **Single-Page Application (SPA)** đầy đủ.                        |
| **35. Static Exports**                        | Bắt đầu như **website tĩnh hoặc SPA**, sau đó nâng cấp để dùng các tính năng server.                   |
| **36. Tailwind CSS v3**                       | Sử dụng **Tailwind CSS v3** để style ứng dụng với độ tương thích trình duyệt cao hơn.                  |
| **37. Testing**                               | Thiết lập **kiểm thử (testing)** với **Cypress, Playwright, Vitest, Jest**.                            |
| **38. Third Party Libraries**                 | Tối ưu hiệu suất **thư viện bên thứ ba** bằng package `@next/third-parties`.                           |
| **39. Upgrading**                             | Cập nhật lên **phiên bản Next.js mới nhất**.                                                           |
| **40. Videos**                                | Hướng dẫn **tối ưu video** trong ứng dụng Next.js.                                                     |

---

✅ **Tóm tắt:**

* “Guides” là tài liệu chuyên sâu — nơi bạn học **cách triển khai và vận hành ứng dụng Next.js trong môi trường thực tế**.
* Bao quát từ **bảo mật, hiệu suất, kiểm thử, deployment, i18n, caching, authentication**, đến **PWA, CI/CD và debugging**.
* Mỗi mục sẽ được trình bày chi tiết trong các phần tiếp theo.

---

# **Phần 1: Analytics — Thêm phân tích hiệu suất cho ứng dụng Next.js**

## 🎯 **Cách thêm phân tích (Analytics) vào ứng dụng Next.js**

Next.js có **hỗ trợ tích hợp sẵn** cho việc **đo lường và báo cáo các chỉ số hiệu suất (performance metrics)**.
Bạn có hai lựa chọn chính:

1. **Tự quản lý việc báo cáo** bằng hook `useReportWebVitals`.
2. **Sử dụng dịch vụ quản lý tự động của Vercel**, cho phép **thu thập và hiển thị biểu đồ hiệu suất** mà không cần cài đặt thủ công.

---

## ⚙️ **Client Instrumentation**

Đối với các nhu cầu phân tích và giám sát nâng cao hơn (advanced analytics & monitoring),
Next.js cung cấp file đặc biệt **`instrumentation-client.js` | `instrumentation-client.ts`** —
file này **chạy trước khi mã frontend của ứng dụng khởi động**.

Điều này **lý tưởng để thiết lập các công cụ toàn cục (global tools)** như:

* Theo dõi lỗi (error tracking)
* Giám sát hiệu suất (performance monitoring)
* Khởi tạo dịch vụ phân tích (analytics SDK)

### 🔧 Cách sử dụng:

Tạo file `instrumentation-client.js` hoặc `instrumentation-client.ts` ở thư mục gốc của ứng dụng:

```js
// instrumentation-client.js

// Khởi tạo analytics trước khi app bắt đầu
console.log('Analytics initialized')

// Thiết lập theo dõi lỗi toàn cục
window.addEventListener('error', (event) => {
  // Gửi lỗi đến hệ thống giám sát của bạn
  reportError(event.error)
})
```

---

## 🧱 **Tự xây dựng Web Vitals Tracking (Build Your Own)**

Bạn có thể tự viết component nhỏ để theo dõi các chỉ số **Web Vitals** bằng hook `useReportWebVitals`.

```js
// app/_components/web-vitals.js

'use client'

import { useReportWebVitals } from 'next/web-vitals'

export function WebVitals() {
  useReportWebVitals((metric) => {
    console.log(metric)
  })
}
```

Và import component này vào layout gốc:

```js
// app/layout.js

import { WebVitals } from './_components/web-vitals'

export default function Layout({ children }) {
  return (
    <html>
      <body>
        <WebVitals />
        {children}
      </body>
    </html>
  )
}
```

### 💡 Lưu ý quan trọng:

Vì `useReportWebVitals` yêu cầu **directive `'use client'`**,
nên **tốt nhất là tạo component riêng biệt** (ví dụ `WebVitals`)
và chỉ import component đó trong layout gốc.
Điều này giúp **giới hạn phạm vi client-side** chỉ ở WebVitals component → cải thiện hiệu suất render.

---

## 📊 **Web Vitals là gì?**

**Web Vitals** là tập hợp các chỉ số đo **trải nghiệm người dùng thực tế trên trang web**.
Next.js cung cấp sẵn các chỉ số sau:

| Tên                                 | Ý nghĩa                                                                              |
| ----------------------------------- | ------------------------------------------------------------------------------------ |
| **TTFB** (Time to First Byte)       | Thời gian từ khi người dùng gửi request đến khi nhận byte đầu tiên từ server.        |
| **FCP** (First Contentful Paint)    | Thời điểm phần tử nội dung đầu tiên được hiển thị.                                   |
| **LCP** (Largest Contentful Paint)  | Thời điểm phần tử nội dung lớn nhất hiển thị hoàn chỉnh.                             |
| **FID** (First Input Delay)         | Độ trễ giữa lần tương tác đầu tiên của người dùng và khi trình duyệt phản hồi.       |
| **CLS** (Cumulative Layout Shift)   | Đo độ “xê dịch layout” trong khi tải trang.                                          |
| **INP** (Interaction to Next Paint) | Thời gian từ khi người dùng tương tác đến khi giao diện phản hồi bằng paint kế tiếp. |

Bạn có thể xử lý từng chỉ số dựa vào thuộc tính `metric.name`.

```tsx
// app/_components/web-vitals.tsx

'use client'

import { useReportWebVitals } from 'next/web-vitals'

export function WebVitals() {
  useReportWebVitals((metric) => {
    switch (metric.name) {
      case 'FCP': {
        // Xử lý kết quả FCP
        break
      }
      case 'LCP': {
        // Xử lý kết quả LCP
        break
      }
      // ...
    }
  })
}
```

---

## 🌐 **Gửi kết quả đến hệ thống bên ngoài**

Bạn có thể **gửi dữ liệu Web Vitals đến bất kỳ endpoint nào** để lưu trữ và phân tích hiệu suất người dùng thực.

Ví dụ:

```js
useReportWebVitals((metric) => {
  const body = JSON.stringify(metric)
  const url = 'https://example.com/analytics'

  // Ưu tiên sử dụng navigator.sendBeacon() nếu có, fallback sang fetch()
  if (navigator.sendBeacon) {
    navigator.sendBeacon(url, body)
  } else {
    fetch(url, { body, method: 'POST', keepalive: true })
  }
})
```

### 💡 Lưu ý:

Nếu bạn dùng **Google Analytics (GA)**, có thể tận dụng `metric.id`
để xây dựng **phân phối thống kê (distribution)**, ví dụ để tính percentile (90th, 95th...).

Ví dụ gửi dữ liệu Web Vitals đến **Google Analytics**:

```js
useReportWebVitals((metric) => {
  // Sử dụng window.gtag nếu bạn đã khởi tạo GA như ví dụ chính thức:
  // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics
  window.gtag('event', metric.name, {
    value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
    event_label: metric.id,      // ID duy nhất cho mỗi lần tải trang
    non_interaction: true,       // Không ảnh hưởng đến bounce rate
  })
})
```

📘 Tham khảo thêm: [Sending results to Google Analytics](https://github.com/vercel/next.js/tree/canary/examples/with-google-analytics)

---

## 📚 **API Reference**

* [`useReportWebVitals`](https://nextjs.org/docs/app/api-reference/functions/use-report-web-vitals)
* [`instrumentation-client.js`](https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation-client)

---

## ✅ **Tóm tắt nhanh**

| Nội dung                        | Mô tả                                                                            |
| ------------------------------- | -------------------------------------------------------------------------------- |
| **`useReportWebVitals`**        | Hook để thu thập và gửi các chỉ số Web Vitals.                                   |
| **`instrumentation-client.js`** | File đặc biệt khởi chạy **trước mã frontend**, dùng để cài đặt công cụ giám sát. |
| **Web Vitals**                  | Bộ chỉ số đánh giá trải nghiệm thực tế của người dùng.                           |
| **Kết nối hệ thống ngoài**      | Gửi dữ liệu đến endpoint hoặc Google Analytics để theo dõi hiệu suất thực tế.    |

---
## Phần 2: Xác thực (Authentication)

Cách triển khai xác thực trong Next.js
Hiểu rõ cơ chế xác thực là điều cốt lõi để bảo vệ dữ liệu của ứng dụng. Phần này hướng dẫn cách sử dụng các tính năng của React và Next.js để triển khai hệ thống xác thực.

Trước khi bắt đầu, ta chia quá trình này thành 3 khái niệm:

* **Authentication (Xác thực):** Xác minh người dùng có đúng là họ nói hay không. Yêu cầu họ chứng minh danh tính bằng thứ gì đó họ có, như tên đăng nhập và mật khẩu.
* **Session Management (Quản lý phiên):** Theo dõi trạng thái đăng nhập của người dùng giữa các request.
* **Authorization (Phân quyền):** Quyết định người dùng được phép truy cập route hoặc dữ liệu nào.

Sơ đồ dưới minh họa luồng xác thực sử dụng các tính năng của React và Next.js.

Các ví dụ trong tài liệu này minh họa quá trình xác thực cơ bản bằng tên người dùng và mật khẩu. Mặc dù bạn có thể tự triển khai hệ thống xác thực, nhưng để tăng bảo mật và đơn giản hóa, nên dùng **thư viện xác thực (Auth Library)**. Các thư viện này cung cấp sẵn chức năng xác thực, quản lý phiên, phân quyền, đăng nhập mạng xã hội, xác thực đa yếu tố (MFA), và kiểm soát truy cập theo vai trò (RBAC). Danh sách được liệt kê trong phần **Auth Libraries**.

---

### Authentication

#### Đăng ký và đăng nhập

Bạn có thể sử dụng thẻ `<form>` kết hợp với **Server Actions** và **useActionState** trong React để lấy thông tin người dùng, kiểm tra hợp lệ, và gọi API hoặc database của nhà cung cấp xác thực.

Vì **Server Actions** luôn chạy trên server nên đây là môi trường an toàn để xử lý logic xác thực.

**Các bước thực hiện:**

**1. Thu thập thông tin người dùng:**
Tạo form gọi Server Action khi submit. Ví dụ form đăng ký nhận tên, email và mật khẩu:
*(code giữ nguyên như bản gốc)*

**2. Xác thực dữ liệu trên server:**
Dùng Server Action để kiểm tra hợp lệ. Nếu nhà cung cấp chưa hỗ trợ, có thể dùng thư viện như **Zod** hoặc **Yup** để kiểm tra schema.
*(code giữ nguyên như bản gốc)*

Nếu dữ liệu không hợp lệ, return sớm để tránh gọi API hoặc database không cần thiết.
*(code giữ nguyên như bản gốc)*

Trong component `<SignupForm />`, dùng `useActionState` để hiển thị lỗi khi form đang submit.
*(code giữ nguyên như bản gốc)*

**Lưu ý:**

* Trong React 19, `useFormStatus` có thêm nhiều thuộc tính như `data`, `method`, `action`. Nếu không dùng React 19, chỉ có `pending`.
* Trước khi thay đổi dữ liệu, luôn đảm bảo người dùng có quyền thực hiện hành động đó (Authorization).

**3. Tạo tài khoản hoặc kiểm tra thông tin đăng nhập:**
Sau khi kiểm tra hợp lệ, tạo tài khoản hoặc xác minh người dùng qua API hoặc database.
*(code giữ nguyên như bản gốc)*

Khi tạo tài khoản thành công hoặc xác thực thành công, tạo **session** để quản lý trạng thái đăng nhập. Session có thể lưu trong cookie, database hoặc cả hai (chi tiết ở phần Session Management).

**Mẹo:**

* Đoạn ví dụ dài dòng để giải thích chi tiết từng bước, giúp bạn thấy rõ việc tự xây dựng hệ thống xác thực an toàn phức tạp ra sao.
* Nên dùng **Auth Library** để giảm công sức.
* Có thể kiểm tra trùng email hoặc username sớm hơn trong quá trình nhập bằng debounce (ví dụ với `use-debounce`) để tránh submit form không cần thiết.

---

### Session Management

Quản lý phiên đảm bảo trạng thái đăng nhập của người dùng được duy trì giữa các request. Bao gồm tạo, lưu trữ, làm mới và xóa session/token.

**Hai loại session chính:**

* **Stateless:** Dữ liệu lưu trực tiếp trong cookie, được gửi đi trong mỗi request. Dễ triển khai nhưng kém an toàn nếu làm sai.
* **Database:** Lưu dữ liệu phiên trong database, còn trình duyệt chỉ giữ ID mã hóa. An toàn hơn, nhưng phức tạp và tốn tài nguyên hơn.

Khuyến nghị: sử dụng thư viện như **iron-session** hoặc **jose**.

---

### Stateless Sessions

**Bước 1:** Tạo secret key
Dùng lệnh:

```bash
openssl rand -base64 32
```

Lưu vào file `.env`:

```
SESSION_SECRET=your_secret_key
```

**Bước 2:** Mã hóa / Giải mã session
Dùng thư viện **Jose** để mã hóa JWT session.
*(code giữ nguyên như bản gốc)*

**Lưu ý:** Payload chỉ nên chứa dữ liệu tối thiểu như userId, role,... Không nên chứa thông tin nhạy cảm (email, password, thẻ tín dụng,...).

**Bước 3:** Lưu session trong cookie
Dùng API `cookies` của Next.js. Nên cấu hình cookie với:

* `HttpOnly: true`
* `Secure: true`
* `SameSite: 'lax'`
* `Expires` hoặc `Max-Age`
  *(code giữ nguyên như bản gốc)*

Sau đó gọi `createSession()` trong Server Action và dùng `redirect()` để điều hướng.
*(code giữ nguyên như bản gốc)*

**Mẹo:**
Cookie nên được set ở server để tránh bị sửa đổi từ client.

---

### Làm mới (refresh) session

Có thể gia hạn thời gian hết hạn của session khi người dùng quay lại app.
*(code giữ nguyên như bản gốc)*

---

### Xóa session

Dùng `cookies().delete('session')` để xóa cookie khi logout.
*(code giữ nguyên như bản gốc)*

---

### Database Sessions

Tạo bảng lưu session, thêm logic thêm/xóa/cập nhật.
Mã hóa session ID trước khi lưu vào cookie.
*(code giữ nguyên như bản gốc)*

**Mẹo:**

* Có thể cache session trong memory để giảm truy vấn.
* Dùng database sessions để quản lý thiết bị đăng nhập hoặc cho phép người dùng logout khỏi tất cả thiết bị.

---

### Authorization

Sau khi xác thực và tạo session, cần kiểm soát quyền truy cập.

**Hai loại kiểm tra:**

* **Optimistic:** Dựa vào session trong cookie, nhanh nhưng ít an toàn.
* **Secure:** Kiểm tra session trong database, an toàn hơn cho dữ liệu nhạy cảm.

---

### Kiểm tra Optimistic với Middleware

Dùng Middleware để chặn hoặc redirect người dùng dựa theo session.
*(code giữ nguyên như bản gốc)*

**Lưu ý:**
Middleware chỉ nên đọc session từ cookie, tránh truy vấn database để không ảnh hưởng hiệu suất.

---

### Tầng Truy cập Dữ liệu (DAL - Data Access Layer)

DAL giúp gom logic kiểm tra quyền truy cập và truy vấn dữ liệu.
Tạo hàm `verifySession()` để xác minh session, trả về userId hợp lệ hoặc redirect `/login`.
*(code giữ nguyên như bản gốc)*

---

### DTO (Data Transfer Object)

Khi trả dữ liệu, chỉ trả phần cần thiết (id, name, role,...) để tránh lộ thông tin nhạy cảm.
*(code giữ nguyên như bản gốc)*

---

### Server Components

Dùng xác thực trong Server Components để hiển thị giao diện theo vai trò người dùng (admin/user).
*(code giữ nguyên như bản gốc)*

---

### Layouts và kiểm tra xác thực

Không nên kiểm tra trong Layout vì chúng không re-render khi điều hướng. Thay vào đó, kiểm tra ở DAL gần nguồn dữ liệu.
*(code giữ nguyên như bản gốc)*

---

### Server Actions và Route Handlers

Đối xử với Server Actions và API Routes như endpoint công khai – luôn xác minh quyền trước khi xử lý.
*(code giữ nguyên như bản gốc)*

---

### Context Providers

Auth context chỉ hoạt động trong Client Components. Nếu cần session trong Client, dùng `taintUniqueValue` để tránh lộ dữ liệu nhạy cảm.
*(code giữ nguyên như bản gốc)*

---

### Tài nguyên

**Auth Libraries:**
Auth0, Better Auth, Clerk, Kinde, Logto, NextAuth.js, Ory, Stack Auth, Supabase, Stytch, WorkOS

**Session Management Libraries:**
Iron Session, Jose

**Tài liệu đọc thêm:**

* Security trong Next.js
* XSS Attacks
* CSRF Attacks
* The Copenhagen Book
---
## Phần 3. **Backend for Frontend (BFF) với Next.js**

Next.js hỗ trợ mô hình **Backend for Frontend**, cho phép tạo các **public endpoints** để xử lý HTTP request và trả về mọi loại content—not chỉ HTML. Ngoài ra, bạn có thể truy cập nhiều nguồn dữ liệu và thực hiện side effects như cập nhật dữ liệu từ remote API.

Nếu bắt đầu dự án mới, dùng:

```bash
npx create-next-app@latest --api
```

* Tùy chọn `--api` tự động tạo ví dụ `route.ts` trong folder `app/` minh họa cách tạo API endpoint.
* Lưu ý: Next.js **không thay thế hoàn toàn backend**, nó chỉ cung cấp layer API:

  * Truy cập công khai
  * Xử lý mọi HTTP request
  * Trả về bất kỳ content type nào

---

### 1. Route Handlers

* **Route Handlers** là public HTTP endpoints, client nào cũng gọi được.
* Tạo file `route.ts` hoặc `route.js` trong `app/api/`:

```ts
// /app/api/route.ts
export function GET(request: Request) {}
```

* Với POST hoặc các thao tác có thể throw exception, dùng `try/catch`:

```ts
import { submit } from '@/lib/submit'

export async function POST(request: Request) {
  try {
    await submit(request)
    return new Response(null, { status: 204 })
  } catch (reason) {
    const message = reason instanceof Error ? reason.message : 'Unexpected error'
    return new Response(message, { status: 500 })
  }
}
```

* **Không tiết lộ thông tin nhạy cảm trong lỗi.**
* Hạn chế truy cập: kết hợp với authentication & authorization.

---

### 2. Content Types & Custom Endpoints

* Route Handlers trả JSON, XML, hình ảnh, file, text.
* File conventions: `sitemap.xml`, `favicon.ico`, `manifest.json`, `robots.txt`
* Custom endpoints: `rss.xml`, `llms.txt`, `.well-known`

Ví dụ RSS feed:

```ts
// /app/rss.xml/route.ts
export async function GET(request: Request) {
  const rssResponse = await fetch('/* rss endpoint */')
  const rssData = await rssResponse.json()

  const rssFeed = `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
 <title>${rssData.title}</title>
 <description>${rssData.description}</description>
 <link>${rssData.link}</link>
 <copyright>${rssData.copyright}</copyright>
 ${rssData.items.map(item => `<item>
    <title>${item.title}</title>
    <description>${item.description}</description>
    <link>${item.link}</link>
    <pubDate>${item.publishDate}</pubDate>
    <guid isPermaLink="false">${item.guid}</guid>
 </item>`)}
</channel>
</rss>`

  const headers = new Headers({ 'content-type': 'application/xml' })
  return new Response(rssFeed, { headers })
}
```

* **Sanitize mọi input** trước khi tạo markup.

---

### 3. Consuming Request Payloads

* Dùng `.json()`, `.formData()`, `.text()` để đọc request body. GET/HEAD không có body.

```ts
// /app/api/echo-body/route.ts
export async function POST(request: Request) {
  const res = await request.json()
  return Response.json({ res })
}
```

* Validate dữ liệu trước khi gửi đến hệ thống khác.

```ts
// /app/api/send-email/route.ts
import { sendMail, validateInputs } from '@/lib/email-transporter'

export async function POST(request: Request) {
  const formData = await request.formData()
  const email = formData.get('email')
  const contents = formData.get('contents')

  try {
    await validateInputs({ email, contents })
    const info = await sendMail({ email, contents })
    return Response.json({ messageId: info.messageId })
  } catch (reason) {
    const message = reason instanceof Error ? reason.message : 'Unexpected exception'
    return new Response(message, { status: 500 })
  }
}
```

* **Request body chỉ đọc 1 lần**, clone nếu cần:

```ts
const clonedRequest = request.clone()
await request.body()
await clonedRequest.body()
```

---

### 4. Manipulating Data

* Transform, filter, aggregate dữ liệu từ nhiều nguồn.
* Offload tính toán nặng về server để giảm tải client.

```ts
import { parseWeatherData } from '@/lib/weather'

export async function POST(request: Request) {
  const body = await request.json()
  const searchParams = new URLSearchParams({ lat: body.lat, lng: body.lng })

  try {
    const weatherResponse = await fetch(`${weatherEndpoint}?${searchParams}`)
    const weatherData = await weatherResponse.text()
    const payload = parseWeatherData.asJSON(weatherData)
    return new Response(payload, { status: 200 })
  } catch (reason) {
    const message = reason instanceof Error ? reason.message : 'Unexpected exception'
    return new Response(message, { status: 500 })
  }
}
```

* POST tốt hơn GET khi chứa dữ liệu nhạy cảm (ví dụ geo-location).

---

### 5. Proxying & Rewrites

* Route Handler có thể proxy đến backend khác, kèm validation:

```ts
import { isValidRequest } from '@/lib/utils'

export async function POST(request: Request, { params }) {
  const clonedRequest = request.clone()
  if (!(await isValidRequest(clonedRequest))) {
    return new Response(null, { status: 400, statusText: 'Bad Request' })
  }

  const { slug } = await params
  const pathname = slug.join('/')
  const proxyURL = new URL(pathname, 'https://nextjs.org')
  return fetch(new Request(proxyURL, request))
}
```

* Hoặc dùng middleware / rewrites trong `next.config.js`.

---

### 6. NextRequest & NextResponse

* **NextRequest**: mở rộng Request, truy cập `nextUrl`.
* **NextResponse**: helper `json()`, `redirect()`, `rewrite()`, cookie manipulation.

```ts
import { NextResponse, type NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  const nextUrl = request.nextUrl
  if (nextUrl.searchParams.get('redirect')) return NextResponse.redirect(new URL('/', request.url))
  if (nextUrl.searchParams.get('rewrite')) return NextResponse.rewrite(new URL('/', request.url))
  return NextResponse.json({ pathname: nextUrl.pathname })
}
```

---

### 7. Webhooks & Callback URLs

* Nhận event từ 3rd-party hoặc CMS:

```ts
export async function GET(request: NextRequest) {
  const token = request.nextUrl.searchParams.get('token')
  if (token !== process.env.REVALIDATE_SECRET_TOKEN) return NextResponse.json({ success: false }, { status: 401 })

  const tag = request.nextUrl.searchParams.get('tag')
  if (!tag) return NextResponse.json({ success: false }, { status: 400 })

  revalidateTag(tag)
  return NextResponse.json({ success: true })
}
```

* Callback URL: verify response, redirect client:

```ts
export async function GET(request: NextRequest) {
  const token = request.nextUrl.searchParams.get('session_token')
  const redirectUrl = request.nextUrl.searchParams.get('redirect_url')

  const response = NextResponse.redirect(new URL(redirectUrl, request.url))
  response.cookies.set({ name: '_token', value: token, path: '/', secure: true, httpOnly: true })
  return response
}
```

---

### 8. Redirects

```ts
import { redirect } from 'next/navigation'

export async function GET(request: Request) {
  redirect('https://nextjs.org/')
}
```

---

### 9. Middleware

* Một file middleware duy nhất/project, target path với `config.matcher`.
* Middleware có thể check auth, rewrite, redirect, proxy:

```ts
import { NextResponse } from 'next/server'

export const config = { matcher: '/api/:function*' }
export function middleware(request: Request) {
  if (!isAuthenticated(request)) return Response.json({ success: false }, { status: 401 })
}
```

* Redirect & proxy:

```ts
if (request.nextUrl.pathname === '/v1/docs') {
  request.nextUrl.pathname = '/v2/docs'
  return NextResponse.redirect(request.nextUrl)
}
```

---

### 10. Security & Best Practices

* Kiểm soát headers, không truyền trực tiếp request headers ra client.
* Rate limiting: code-level + host-level.
* Validate payload, chống XSS, timeout để bảo vệ server.
* Store static assets ở dịch vụ chuyên dụng, upload từ client nếu có thể.
* Xác thực trước khi cấp quyền, rotate credentials/API keys.
* Preflight (OPTIONS) & CORS: Next.js tự set header dựa trên method.

---

### 11. Library Patterns

* Factory pattern cho Route Handlers:

```ts
import { createHandler } from 'third-party-library'
const handler = createHandler({ /* options */ })
export const GET = handler
export { handler as POST }
```

* Middleware factory:

```ts
import { createMiddleware } from 'third-party-library'
export default createMiddleware()
```

---

### 12. Caveats

* **Server Components** fetch data trực tiếp, không qua Route Handler build-time.

  * Pre-rendered Server Components tại build time: Route Handlers sẽ fail vì lúc build không có server.
  *


  Server Components render on-demand: fetching qua Route Handlers chậm hơn do HTTP round trip.

  * Fetch server-side cần **absolute URLs**, dev server đóng vai trò external server. Build time không có server, runtime dùng domain public.

  Server Components đáp ứng hầu hết nhu cầu fetch dữ liệu. **Client-side fetch** chỉ cần khi:

  * Data phụ thuộc Web APIs client-only: Geo-location, Storage, Audio, File
  * Data cần poll thường xuyên

  Dùng library như **swr** hoặc **react-query** cho các trường hợp này.

* **Server Actions** mutate data client-side, queued execution.
  * Chạy server-side code từ client.
  * Mục đích chính: mutate data từ frontend.
  * Server Actions **queue**, dùng để fetch dữ liệu có thể gây sequential execution.
* **Export mode**: chỉ GET Route Handlers, static HTML/JSON/TXT.
  * Xuất static site, không runtime server.
  * Chỉ hỗ trợ **GET Route Handlers** với `dynamic = 'force-static'`.
  * Tạo HTML/JSON/TXT hoặc file khác.

  ```ts
  // app/hello-world/route.ts
  export const dynamic = 'force-static'

  export function GET() {
    return new Response('Hello World', { status: 200 })
  }
  ```
* Một số host deploy Route Handlers `Lambda hosts`:
  * Không share data giữa requests
  * Giới hạn file system
  * Long-running handler bị terminate do timeout
  * WebSocket không hoạt động
###  API Reference

* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
* [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware)
* `route.js`: API reference file đặc biệt
* `middleware.js`: API reference middleware
---

Next.js BFF phù hợp khi muốn:

* Ẩn API nội bộ
* Xử lý logic/validation/server-side tracking
* Tích hợp nhiều backend / dịch vụ 3rd-party
* Proxy request, xử lý dữ liệu trước client
