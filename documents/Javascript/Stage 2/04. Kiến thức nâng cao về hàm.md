# 4. Kiến thức nâng cao về hàm

<details>
<summary><strong>1. Hàm đệ quy trong JavaScript</strong></summary>

---

## **1. Khái niệm**

* Hàm đệ quy là hàm **tự gọi lại chính nó**.
* Thường sử dụng khi bài toán có thể chia thành nhiều **bài toán con cùng dạng**.

### **Cấu trúc cơ bản**

```js
function recursionExample(param) {
  // phần cơ sở: điều kiện thoát đệ quy
  if (condition) return;

  // phần đệ quy: gọi lại chính hàm
  recursionExample(newParam);
}
```

* **Phần cơ sở**: điều kiện để thoát đệ quy, tránh **stack overflow**.
* **Phần đệ quy**: gọi lại chính hàm.

---

## **2. Ví dụ cơ bản**

```js
function sayHello(count) {
  if (count <= 0) return;

  console.log("Hello world!");
  sayHello(count - 1);
}

sayHello(5);
```

**Kết quả:**

```
Hello world!
Hello world!
Hello world!
Hello world!
Hello world!
```

> Nếu bỏ phần cơ sở, hàm sẽ chạy **vô hạn** và gây lỗi **tràn stack**.

---

## **3. Khi nào dùng đệ quy**

* Bài toán có thể chia nhỏ thành **bài toán con tương tự bài toán gốc**.
* Ví dụ: tính **lũy thừa**, **giai thừa**, **Fibonacci**, xử lý **danh sách liên kết**, **cây**, v.v.

```js
// tính a^b
function power(a, b) {
  if (b === 0) return 1;
  return a * power(a, b - 1);
}

console.log(power(2, 3)); // 8
```

* Có thể dùng vòng lặp, nhưng **đệ quy giúp code ngắn gọn và rõ ràng hơn**.

---

## **4. So sánh vòng lặp và đệ quy**

| Tiêu chí      | Vòng lặp                        | Đệ quy                                       |
| ------------- | ------------------------------- | -------------------------------------------- |
| Bộ nhớ        | Tối ưu (chỉ 1 lần gọi)          | Tốn call stack, có thể tràn stack            |
| Tính ngắn gọn | Ít trực quan                    | Ngắn gọn, dễ đọc                             |
| Thích hợp     | Khi cần tối ưu thời gian/bộ nhớ | Khi ưu tiên code dễ bảo trì và logic rõ ràng |

---

## **5. Thực hành**

### **Bài 1: sumTo(n)**

Tính tổng từ 1 đến n.

**Vòng lặp:**

```js
function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) sum += i;
  return sum;
}
```

**Đệ quy:**

```js
function sumTo(n) {
  if (n === 1) return 1;
  return n + sumTo(n - 1);
}
```

**Công thức toán học:**

```js
function sumTo(n) {
  return (n * (n + 1)) / 2;
}
```

---

### **Bài 2: factorial(n)**

**Vòng lặp:**

```js
function factorial(n) {
  let ret = 1;
  for (let i = 1; i <= n; i++) ret *= i;
  return ret;
}
```

**Đệ quy:**

```js
function factorial(n) {
  if (n === 0) return 1;
  return n * factorial(n - 1);
}
```

---

### **Bài 3: fibonacci(n)**

```js
function fibonacci(n) {
  if (n === 0 || n === 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
}
```

---

### **Bài 4: In danh sách liên kết (single linked list)**

```js
let list = {
  value: 1,
  next: {
    value: 2,
    next: { value: 3, next: { value: 4, next: null } }
  }
};

// Vòng lặp
function printList(list) {
  let p = list;
  while (p) {
    console.log(p.value);
    p = p.next;
  }
}

// Đệ quy
function printList(list) {
  if (!list) return;
  console.log(list.value);
  printList(list.next);
}
```

---

### **Bài 5: In danh sách liên kết ngược**

```js
// Vòng lặp
function printReverseList(list) {
  let arr = [];
  let p = list;
  while (p) {
    arr.push(p.value);
    p = p.next;
  }
  for (let i = arr.length - 1; i >= 0; i--) {
    console.log(arr[i]);
  }
}

// Đệ quy
function printReverseList(list) {
  if (list.next) printReverseList(list.next);
  console.log(list.value);
}
```

---

## **6. Tổng kết**

* **Đệ quy** là kỹ thuật mạnh mẽ, đặc biệt khi xử lý:

  * Bài toán phân chia (divide & conquer)
  * Cấu trúc dữ liệu **cây** và **danh sách liên kết**
  * Tính toán lũy thừa, giai thừa, Fibonacci
* **Nhớ luôn có điều kiện cơ sở** để tránh tràn stack.
* Khi ưu tiên **hiệu năng**, vòng lặp có thể là lựa chọn tốt hơn.

</details>
<details>
<summary><strong>2. Dấu ba chấm trong JavaScript (...)</strong></summary>

---

## **1. Tham số còn lại (Rest Parameters)**

* Dùng khi muốn gom các tham số dư thừa của hàm thành một **mảng**.
* **Cú pháp:** `...args` **phải đặt cuối cùng** trong danh sách tham số.

```js
function sumAll(...args) {
  let sum = 0;
  for (let arg of args) sum += arg;
  return sum;
}

console.log(sumAll(1,2,3)); // 6
```

* Có thể kết hợp với một vài tham số đầu tiên:

```js
function showName(firstName, lastName, ...titles) {
  console.log(`${firstName} ${lastName}`);
  console.log(titles); // ["Consul", "Imperator"]
}

showName("Julius", "Caesar", "Consul", "Imperator");
```

**Lưu ý:** không được đặt `...rest` ở giữa danh sách tham số, sẽ gây lỗi.

---

### **Đối tượng `arguments`**

* Là object **array-like**, chứa tất cả các tham số hàm.
* Không phải là mảng thực sự, nên không dùng trực tiếp các phương thức như `.map()`.
* Arrow function **không có** `arguments`.

```js
function sumAll() {
  for (let i = 0; i < arguments.length; i++) {
    console.log(arguments[i]);
  }
}
sumAll(1,2,3);
```

---

## **2. Cú pháp Spread (`...`)**

* Ngược lại với rest: tách **mảng hoặc iterable** thành danh sách các phần tử.
* Dùng trong:

  * Gọi hàm
  * Tạo mảng mới
  * Tạo object mới

### **Ví dụ với hàm**

```js
let arr = [4,7,5];
console.log(Math.max(...arr)); // 7
```

* Có thể kết hợp nhiều mảng:

```js
let arr1 = [3,5,1];
let arr2 = [4,6,2];
console.log(Math.max(...arr1, ...arr2)); // 6
```

### **Ghép và copy mảng**

```js
let arr1 = [3,5,1];
let arr2 = [4,6,2];
let arr = [...arr1, ...arr2];
console.log(arr); // [3,5,1,4,6,2]

let arrCopy = [...arr];
```

### **Copy object**

```js
let obj = { a:1, b:2, c:3 };
let objCopy = { ...obj };

console.log(objCopy); // { a:1, b:2, c:3 }
```

* **Lưu ý:** spread tạo **bản sao nông (shallow copy)**, không cùng tham chiếu.

---

### **Spread với string hoặc iterable**

```js
let str = "Hello";
console.log([...str]); // ['H','e','l','l','o']
```

---

## **3. Phân biệt Rest vs Spread**

| Đặc điểm | Rest Parameters                              | Spread Syntax                                           |
| -------- | -------------------------------------------- | ------------------------------------------------------- |
| Vị trí   | Trong **định nghĩa hàm**, luôn **cuối cùng** | Trong **lời gọi hàm**, mảng hoặc object                 |
| Mục đích | Gom các tham số dư thành mảng                | Tách mảng/object thành danh sách tham số hoặc key-value |
| Ví dụ    | `function fn(a, b, ...rest)`                 | `fn(...arr)`                                            |

---

## **4. Ứng dụng**

* **Rest Parameters:** xây dựng hàm với số lượng tham số tùy ý.
* **Spread Syntax:**

  * Truyền mảng vào hàm
  * Ghép hoặc copy mảng/object
  * Chuyển iterable thành mảng

</details>
<details>
<summary><strong>3. Closure trong JavaScript</strong></summary>

---

## **1. Closure là gì?**

* Closure = **hàm + môi trường lexical nơi hàm được khai báo**.
* Closure có thể truy cập:

  * Biến toàn cục (global)
  * Biến bên ngoài hàm (outer function)
  * Biến local bên trong chính hàm closure

```js
let YEAR = "2021";

function greet(name) {
  let intro = "Hello";

  function sayHello() {
    let message = `${intro} ${name} in ${YEAR}`;
    console.log(message);
  }

  sayHello();
}

greet("Dev"); // Hello Dev in 2021
```

---

## **2. Code Block & Phạm vi biến**

* `let/const` có **block scope**.
* Biến chỉ có thể truy cập trong `{ ... }` chứa nó.

```js
{
  let message = "Hi";
  console.log(message); // Hi
}
console.log(message); // Error: message is not defined
```

* Áp dụng tương tự cho `if`, `for`, `while`, v.v.

```js
for (let i = 0; i < 3; i++) {
  console.log(i); // 0,1,2
}
console.log(i); // Error
```

---

## **3. Hàm lồng nhau (Nested function)**

* Một hàm khai báo bên trong hàm khác.
* Nested function có thể truy cập biến outer function.

```js
function sayHiBye(firstName, lastName) {
  function getFullName() {
    return `${firstName} ${lastName}`;
  }

  console.log("Hello, " + getFullName());
}
```

---

## **4. Closure lưu biến ngoài hàm**

* Nested function trả về có thể **vẫn truy cập biến cục bộ của outer function** ngay cả khi outer function đã kết thúc.

```js
function makeCounter() {
  let count = 0;
  return function () {
    return count++;
  };
}

let counter1 = makeCounter();
console.log(counter1()); // 0
console.log(counter1()); // 1

let counter2 = makeCounter();
console.log(counter2()); // 0 (độc lập)
```

---

## **5. Closure lưu biến theo tham chiếu**

```js
function ObjId() {
  let id = 1;
  return {
    getId: function () { return id; },
    setId: function (_id) { id = _id; },
  };
}

let myObject = ObjId();
console.log(myObject.getId()); // 1
myObject.setId(10);
console.log(myObject.getId()); // 10
```

* Các closure `getId` & `setId` chia sẻ cùng **biến cục bộ id**.

---

## **6. Ví dụ thực hành**

### Bài 1

```js
let name = "Alex";
function sayHi() { console.log("Hi, " + name); }
name = "Anna";
sayHi(); // Anna
```

* Hàm sử dụng **giá trị mới nhất của biến global**.

---

### Bài 2

```js
function makeWorker() {
  let name = "Alex";
  return function () { console.log(name); };
}

let name = "Anna";
let work = makeWorker();
work(); // Alex
```

* Closure truy cập biến **cục bộ của outer function**, không phải biến global.

---

### Bài 3

```js
"use strict";
if (true) {
  let user = "Alex";
  function sayHi() { console.log(user); }
}
sayHi(); // Error
```

* Hàm `sayHi` chỉ tồn tại trong **block scope**.

---

### Bài 4: Hàm sum(a)(b)

```js
function sum(a) {
  return function (b) {
    return a + b;
  };
}

console.log(sum(1)(2)); // 3
console.log(sum(2)(-1)); // 1
```

* Closure cho phép **currying**.

---

### Bài 5: Temporal Dead Zone (TDZ)

```js
let x = 1;
function func() {
  console.log(x); // Error
  let x = 2;
}
func();
```

* Lỗi vì `let x` chưa được khởi tạo (TDZ).

---

### Bài 6: Closure trong sort

```js
let users = [
  { name: "Alex", age: 28 },
  { name: "Pete", age: 20 },
  { name: "Ann", age: 24 },
];

function byField(fieldName) {
  return (a, b) => (a[fieldName] > b[fieldName] ? 1 : -1);
}

users.sort(byField("name"));
users.sort(byField("age"));
```

* Closure trả về **hàm so sánh** dựa trên `fieldName`.

---

## **Tóm tắt**

* Closure = hàm + **lexical environment**.
* Cho phép hàm **truy cập biến outer function ngay cả khi outer function kết thúc**.
* Lưu biến theo **tham chiếu**, hỗ trợ nhiều pattern như:

  * Private variables
  * Counters
  * Currying
  * Factory functions

</details>
<details>
<summary><strong>4. Var và IIFE trong JavaScript</strong></summary>

---

## **1. Khai báo biến với var**

* `var` là cách khai báo cũ, **không có block scope**.
* Phạm vi của `var`:

  * **Global** nếu khai báo ngoài hàm.
  * **Function** nếu khai báo trong hàm.
* Có thể **khai báo lại nhiều lần** trong cùng phạm vi.
* Hỗ trợ **hoisting**: khai báo được đưa lên đầu phạm vi, nhưng **giá trị gán không được hoisted**.

---

### Ví dụ phạm vi block

```js
if (true) {
  var test = true;
}
console.log(test); // true (var có global/function scope)
```

*So với `let`/`const` chỉ có block scope:*

```js
if (true) {
  let test = true;
}
console.log(test); // Error
```

---

### Ví dụ vòng lặp

```js
for (var i = 0; i < 3; i++) {
  var a = 1;
}

console.log(i); // 3
console.log(a); // 1
```

*`let/const` chỉ nhìn thấy trong vòng lặp.*

---

### Ví dụ trong hàm

```js
function sayHi() {
  if (true) {
    var message = "Hello";
  }
  console.log(message); // Hello
}

sayHi();
console.log(message); // Error, không global
```

---

### Khai báo lại biến

```js
var user = "Alex";
var user = "Anna";
console.log(user); // Anna
```

*`let`/`const` sẽ báo lỗi nếu khai báo lại cùng phạm vi.*

---

### Hoisting với var

```js
function sayHi() {
  console.log(message); // undefined
  var message = "Hello";
}

sayHi();
```

*Biến được **hoisted**, nhưng giá trị gán giữ nguyên vị trí.*

---

## **2. IIFE (Immediately-Invoked Function Expression)**

*Trước ES6, để mô phỏng **block scope** với `var`, người ta dùng IIFE.*

```js
(function () {
  var message = "Hello";
  console.log(message); // Hello
})();
```

*Biến `message` **không thể truy cập ngoài IIFE**.*

---

### Lý do dùng ngoặc đơn

* JavaScript cần **biểu thức hàm** để gọi ngay.
* Nếu viết:

```js
function() {
  var message = "Hello";
}();
```

→ **Lỗi**, vì JS hiểu là function declaration cần tên.

*Đặt ngoặc đơn `(function(){ ... })()` → JS hiểu là function expression.*

---

### Các cách viết IIFE khác

```js
(function(){ console.log("() bao quanh function"); })();
(function(){ console.log("() bao quanh tất cả"); })();
!(function(){ console.log("Toán tử !"); })();
+(function(){ console.log("Toán tử +"); })();
```

> **Lưu ý:** Với JS hiện đại, **không cần dùng IIFE** vì `let`/`const` đã có block scope.

---

## **3. Tổng kết**

| Đặc điểm     | var                                          | let/const                                                |
| ------------ | -------------------------------------------- | -------------------------------------------------------- |
| Phạm vi      | Function hoặc global                         | Block                                                    |
| Khai báo lại | Có thể                                       | Lỗi                                                      |
| Hoisting     | Khai báo được hoisted, giá trị không hoisted | Hoisted nhưng TDZ, không thể truy cập trước khi khai báo |

*IIFE chỉ dùng để tạo **phạm vi riêng**, chủ yếu gặp trong code cũ với `var`.*

</details>
<details>
<summary><strong>5. Đối tượng Global trong JavaScript</strong></summary>

---

## **1. Đối tượng global là gì?**

* Là **nơi chứa các biến và hàm có thể truy cập ở mọi nơi** trong chương trình.
* Trên **trình duyệt** → `window`.
* Trong **Node.js** → `global`.
* Chuẩn mới → `globalThis` (tương thích tất cả môi trường).

---

### **Truy cập biến/hàm toàn cục**

```js
console.log("Hello");       // bình thường
window.console.log("Hello"); // tương đương
```

---

### **Biến/hàm toàn cục với var và function**

```js
var gVar = 6;
console.log(window.gVar); // 6

function sayHi() {
  console.log("Hi!");
}
window.sayHi(); // Hi!
```

*Nhưng với let/const:*

```js
let gLet = 6;
console.log(window.gLet); // undefined
```

---

### **Chủ động tạo thuộc tính trên global object**

```js
window.currentUser = { name: "Alex" };
console.log(currentUser.name);       // Alex
console.log(window.currentUser.name); // Alex
```

*Lưu ý:* Chỉ nên làm khi thực sự cần biến toàn cục.

---

## **2. Sử dụng global object để polyfills**

* Kiểm tra tính năng có hỗ trợ hay không:

```js
if (!window.Promise) {
  console.log("You're using an old browser!");
}
```

*Thêm polyfill nếu cần:*

```js
if (!window.Promise) {
  window.Promise = ... // triển khai Promise
}
```

---

## **3. Tổng kết**

* `global`/`window`/`globalThis` chứa biến và hàm có thể dùng ở mọi nơi.
* Bao gồm các **built-in object**: `Array`, `Map`, `Set`…
* Trên trình duyệt:

  * Biến **var** → thuộc tính của `window`.
  * Biến **let/const** → không phải thuộc tính global.
* **Nên hạn chế sử dụng biến toàn cục**, vì làm code khó quản lý và debug.
* Sử dụng global object khi **thực sự cần**, hoặc để **polyfills**.

</details>
<details>
<summary><strong>6. Function trong JavaScript</strong></summary>

---

## **1. Function là object**

* Function trong JavaScript là **một loại object đặc biệt**.
* Bạn có thể:

  * Thêm/xóa thuộc tính vào function.
  * Truyền function qua hàm khác bằng **tham chiếu**.

---

## **2. Thuộc tính name của function**

* Trả về **tên hàm**:

```js
function sayHi() {}
console.log(sayHi.name); // sayHi
```

* Khi gán hàm ẩn danh vào biến:

```js
let sayHi = function () {};
console.log(sayHi.name); // sayHi
```

* Thuộc tính `name` có thể lấy từ **ngữ cảnh**, ví dụ gán vào object:

```js
let user = {
  sayHi() {},
  sayBye: function () {}
};

console.log(user.sayHi.name); // sayHi
console.log(user.sayBye.name); // sayBye
```

* Một số trường hợp không xác định được `name`:

```js
let arr = [function () {}];
console.log(arr[0].name); // ""
```

---

## **3. Thuộc tính length**

* Trả về **số lượng tham số định nghĩa trong hàm**, không tính **rest parameter**:

```js
function f(a) {}
function g(a,b) {}
function h(a,b,...more) {}

console.log(f.length); // 1
console.log(g.length); // 2
console.log(h.length); // 2
```

* Ứng dụng: phân biệt handler có tham số hay không:

```js
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for (let handler of handlers) {
    if (handler.length === 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }
}
```

---

## **4. Thêm thuộc tính vào function**

* Ví dụ đếm số lần gọi:

```js
function sayHi() {
  console.log("Hi");
  sayHi.counter++;
}

sayHi.counter = 0;

sayHi(); // Hi
sayHi(); // Hi
console.log(sayHi.counter); // 2
```

* Thay thế closure bằng thuộc tính function:

```js
function makeCounter() {
  function counter() { return counter.count++; }
  counter.count = 0;
  return counter;
}

let counter = makeCounter();
console.log(counter()); // 0
console.log(counter()); // 1

counter.count = 10;
console.log(counter()); // 10
```

---

## **5. Named Function Expression (NFE)**

* Đặt tên cho biểu thức hàm:

```js
let sayHi = function func(who) {
  if (who) console.log(`Hello, ${who}`);
  else func("Guest");
};

sayHi(); // Hello, Guest
```

* Lợi ích:

  * Gọi lại chính hàm **bên trong thân hàm** mà không phụ thuộc biến bên ngoài.
  * Tên hàm **không nhìn thấy từ bên ngoài**.

* Tránh lỗi khi biến gán lại:

```js
let sayHello = sayHi;
sayHi = null;
sayHello(); // vẫn chạy nhờ func bên trong
```

---

## **6. Thực hành: makeCounter() nâng cao**

Yêu cầu:

* `counter()` → trả về giá trị hiện tại, sau đó tăng.
* `counter.set(value)` → gán giá trị count.
* `counter.decrease()` → giảm count đi 1.

```js
function makeCounter() {
  let count = 0;

  return function counter() {
    counter.set = function(value) { count = value; };
    counter.decrease = function() { count--; };
    return count++;
  };
}

let counter = makeCounter();

console.log(counter()); // 0
console.log(counter()); // 1
console.log(counter()); // 2

counter.set(5);
console.log(counter()); // 5

counter.decrease();
console.log(counter()); // 5
```

*Ghi chú:* Kết hợp **closure** với **thuộc tính function object**.

</details>
<details>
<summary><strong>7. Cú pháp <code>new Function</code> trong JavaScript</strong></summary>

---

## **1. Khái niệm**

* `new Function` là **một cách khác để tạo hàm** trong JavaScript.
* Ít khi sử dụng nhưng hữu ích khi cần **tạo hàm từ string runtime**.

---

## **2. Cú pháp**

```js
let func = new Function([arg1, arg2, ...argN], functionBody);
```

* `[arg1, arg2, ...argN]` → danh sách tham số của hàm.
* `functionBody` → **string** chứa code của hàm.

**Ví dụ: hàm tính tổng:**

```js
let sum = new Function("a", "b", "return a + b");
console.log(sum(1, 2)); // 3
```

**Hàm không tham số:**

```js
let sayHi = new Function('console.log("Hello")');
sayHi(); // Hello
```

---

## **3. Đặc điểm quan trọng**

1. Hàm được tạo **runtime**.
2. Thân hàm là **string**.
3. Hàm không lưu thông tin **Lexical Environment** nơi nó được tạo, mà tham chiếu **global**.

**Ví dụ về mối quan hệ với closure:**

```js
window.value = "global value";

function getFunc() {
  let value = "local value";

  let func = new Function("console.log(value)");

  return func;
}

getFunc()(); // "global value"
```

So sánh với hàm thông thường:

```js
function getFunc() {
  let value = "local value";

  let func = function() {
    console.log(value);
  };

  return func;
}

getFunc()(); // "local value"
```

---

## **4. Truyền biến vào hàm**

* Vì `new Function` không thấy biến bên ngoài, cần **truyền tham số**:

```js
let userName = "Alex";

let func = new Function("name", "console.log('Hello ' + name)");
func(userName); // Hello Alex
```

---

## **5. Tổng kết**

* Cú pháp:

```js
let func = new Function([arg1, arg2, ...argN], functionBody);
```

* Các cách truyền tham số:

```js
new Function("a", "b", "return a + b");
new Function("a,b", "return a + b");
new Function("a , b", "return a + b");
```

* **Chú ý:**

  * Hàm không tham chiếu môi trường tạo ra → chỉ dùng được biến global.
  * Truyền biến qua tham số để sử dụng bên trong hàm.
  * Thích hợp khi cần tạo hàm **dynamic từ string**, ví dụ dữ liệu từ server.

</details>
<details>
<summary><strong>8. Hàm <code>setTimeout</code> và <code>setInterval</code> trong JavaScript</strong></summary>

---

## **1. Cú pháp setTimeout**

```js
let timerId = setTimeout(func|code, delay, arg1, arg2, ...);
```

* `func|code`: **hàm** hoặc **string code** (không khuyến khích dùng string).
* `delay`: thời gian trì hoãn trước khi thực thi (ms). Mặc định 0.
* `arg1, arg2,...`: tham số truyền vào hàm.

**Ví dụ:**

```js
function sayHi(message, who) {
  console.log(`${message}, ${who}`);
}

setTimeout(sayHi, 1000, "Hello", "Alex"); // Hello, Alex
```

> ⚠️ Nhớ: **truyền hàm**, không phải kết quả của hàm:
>
> ```js
> setTimeout(sayHi(), 1000); // ❌ Sai
> setTimeout(sayHi, 1000);   // ✅ Đúng
> ```

---

## **2. Hủy timeout với clearTimeout**

```js
let timerId = setTimeout(() => console.log("Hello"), 1000);

// Hủy bỏ timeout
clearTimeout(timerId);
```

---

## **3. Hàm setInterval**

* Cú pháp tương tự `setTimeout`:

```js
let timerId = setInterval(func|code, delay, arg1, arg2, ...);
```

* Thực thi **lặp lại** sau mỗi khoảng thời gian `delay`.
* Dừng hành động: `clearInterval(timerId)`.

**Ví dụ:**

```js
let timerId = setInterval(() => console.log("Hello"), 2000);

setTimeout(() => {
  clearInterval(timerId);
  console.log("stop");
}, 5000);
```

---

## **4. setTimeout lồng nhau (recursive setTimeout)**

* Cho phép **delay linh hoạt hơn** so với setInterval:

```js
let timerId = setTimeout(function sayHi() {
  console.log("Hello");
  timerId = setTimeout(sayHi, 2000); // gọi lại sau 2 giây
}, 2000);
```

* Dùng để **điều chỉnh delay theo trạng thái**, ví dụ gửi request lên server:

```js
let delay = 5000;

let timerId = setTimeout(function request() {
  // gửi request...
  
  if (/* server quá tải */) delay *= 2;
  
  timerId = setTimeout(request, delay);
}, delay);
```

---

## **5. setTimeout với delay = 0**

* Thực tế, hàm vẫn được gọi **sau khi luồng chính hoàn tất**, không thực thi ngay lập tức:

```js
setTimeout(() => console.log("World"), 0);
console.log("Hello");
// Output:
// Hello
// World
```

---

## **6. Thực hành**

### Bài 1: In số từ `start` → `end` mỗi 1 giây

**Cách 1: setInterval**

```js
function printNumbers(start, end) {
  let timerId = setInterval(function run() {
    if (start > end) {
      clearInterval(timerId);
      return;
    }
    console.log(start++);
  }, 1000);
}

printNumbers(1, 5);
```

**Cách 2: setTimeout lồng nhau**

```js
function printNumbers(start, end) {
  setTimeout(function run() {
    if (start > end) return;

    console.log(start++);
    setTimeout(run, 1000);
  }, 1000);
}

printNumbers(1, 5);
```

### Bài 2: setTimeout và vòng lặp dài

```js
let i = 0;

setTimeout(() => console.log(i), 100);

console.log("trước vòng lặp");
for (let j = 0; j < 100000000; j++) i++;
console.log("sau vòng lặp");
```

**Output:**

```
trước vòng lặp
sau vòng lặp
100000000
```

> Hàm `setTimeout` được thực thi **sau khi luồng chính hoàn tất**.

---

## **7. Tổng kết**

* `setTimeout(func, delay, ...args)` → gọi **một lần** sau `delay`.
* `setInterval(func, delay, ...args)` → gọi **lặp đi lặp lại** mỗi `delay`.
* Hủy bỏ: `clearTimeout(timerId)` hoặc `clearInterval(timerId)`.
* **setTimeout lồng nhau** giúp kiểm soát delay chính xác hơn.
* `setTimeout(func, 0)` → thực hiện sau khi luồng chính xong.
* Hàm truyền vào sẽ giữ tham chiếu cho tới khi timeout thực hiện hoặc interval bị clear.

</details>
<details>
<summary><strong>9. Decorator và Forwarding trong JavaScript</strong></summary>

---

## **1. Ý tưởng Decorator**

* Decorator là **hàm nhận một hàm khác làm tham số** và trả về **hàm wrapper** có thêm tính năng.
* Ví dụ: **caching decorator**:

```js
function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) return cache.get(x);

    let result = func(x);
    cache.set(x, result);
    return result;
  };
}
```

* Lợi ích:

  * Tách riêng logic bổ sung (cache, logging, delay...) khỏi hàm gốc.
  * Tái sử dụng cho nhiều hàm.
  * Có thể kết hợp nhiều decorator.

---

## **2. Sử dụng `func.call` và `func.apply`**

Khi decorator wrap **method của object**, cần giữ giá trị `this`:

```js
let worker = {
  someMethod() { return 1; },
  slow(x) { return x * this.someMethod(); }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) return cache.get(x);
    let result = func.call(this, x); // giữ context this
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow);
console.log(worker.slow(2)); // 2
```

* `func.call(context, arg1, arg2, ...)` → gọi hàm với `this=context` và danh sách tham số.
* `func.apply(context, argsArray)` → gọi hàm với `this=context` và tham số dạng array-like.

---

## **3. Caching với nhiều tham số**

* Với nhiều tham số, cần tạo **key duy nhất**:

```js
function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments);
    if (cache.has(key)) return cache.get(key);
    let result = func.apply(this, arguments);
    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return [].join.call(args, ","); // mượn join từ Array để dùng với arguments
}
```

---

## **4. Forwarding**

* Forwarding: **truyền toàn bộ tham số từ hàm wrapper sang hàm gốc**:

```js
let wrapper = function() {
  return func.apply(this, arguments);
};
```

---

## **5. Kỹ thuật mượn phương thức (Method Borrowing)**

* Để dùng các phương thức của Array cho `arguments` (array-like):

```js
function hash(args) {
  return [].join.call(args, ",");
}

console.log(hash(arguments)); // "1,2,3"
```

---

## **6. Lưu trữ thông tin gọi hàm (ví dụ spy)**

```js
function spy(func) {
  function wrapper() {
    wrapper.calls.push([...arguments]); // lưu các tham số
    return func.apply(this, arguments); // forwarding
  }
  wrapper.calls = [];
  return wrapper;
}

// Sử dụng
function work(a, b) { console.log(a + b); }
work = spy(work);

work(1, 2); // 3
work(4, 5); // 9

for (let args of work.calls) {
  console.log("call:" + args.join()); // "call:1,2", "call:4,5"
}
```

---

## **7. Trì hoãn hàm (delay decorator)**

```js
function delay(func, ms) {
  return function() {
    setTimeout(() => func.apply(this, arguments), ms);
  };
}

// Sử dụng
function f(x) { console.log(x); }

let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000("test"); // sau 1000ms
f1500("test"); // sau 1500ms
```

---

## **8. Tổng kết**

* **Decorator**: hàm wrapper thêm tính năng cho hàm gốc mà không làm phức tạp hàm gốc.
* **Call/Apply**: giữ `this` và forwarding tham số.
* **Forwarding**: truyền tất cả tham số từ wrapper sang hàm gốc.
* **Method Borrowing**: dùng phương thức của object khác (thường cho array-like như `arguments`).
* Có thể dùng decorator để **cache**, **spy**, **delay**, **logging**, **throttle**...

</details>
<details>
<summary><strong>10. Function Binding trong JavaScript</strong></summary>

---

## **1. Vấn đề mất `this` khi dùng callback**

Khi sử dụng phương thức của object làm callback, giá trị `this` có thể bị mất:

```js
let user = {
  firstName: "Alex",
  sayHi() {
    console.log(`Hello, ${this.firstName}!`);
  },
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
```

* Nguyên nhân: `setTimeout` gọi hàm độc lập với object, `this` mặc định là `window` (hoặc `undefined` trong strict mode).

---

## **2. Giải pháp: Hàm wrapper**

Sử dụng hàm wrapper hoặc arrow function:

```js
setTimeout(function () { user.sayHi(); }, 1000);
setTimeout(() => user.sayHi(), 1000);
```

* Lưu ý: Nếu object `user` thay đổi trước khi callback chạy, kết quả có thể không đúng.

---

## **3. Function binding với `bind`**

`bind` cố định giá trị `this`:

```js
let sayHi = user.sayHi.bind(user);

sayHi();            // Hello, Alex
setTimeout(sayHi, 1000); // Hello, Alex
```

* `func.bind(context)` trả về hàm mới với `this = context`.

---

## **4. Partial function (bind tham số)**

Bind không chỉ giá trị `this`, mà còn các tham số:

```js
function mul(a, b) { return a * b; }

let double = mul.bind(null, 2); // bind a=2, this=null
console.log(double(3)); // 6
console.log(double(4)); // 8
```

* Partial function: hàm mới với một số tham số cố định.

---

## **5. Partial function giữ `this` động**

Khi muốn cố định tham số nhưng không cố định `this`:

```js
function partial(func, ...argsBound) {
  return function(...args) {
    return func.call(this, ...argsBound, ...args);
  };
}

// Ví dụ:
let user = {
  firstName: "Alex",
  say(time, message) {
    console.log(`[${time}] ${this.firstName}: ${message}!`);
  },
};

user.sayNow = partial(user.say, "10:00");
user.sayNow("Hello"); // [10:00] Alex: Hello!
```

* `this` lấy từ thời điểm gọi `sayNow`, `argsBound` là tham số cố định, `args` là tham số mới.

---

## **6. Một số lưu ý về bind**

1. `bind` trả về **hàm mới**, không thay đổi hàm gốc.
2. Gọi `bind` nhiều lần: giá trị `this` chỉ lấy lần đầu, các lần sau không có hiệu lực.
3. Thuộc tính của hàm gốc **không được copy** sang hàm bind mới.

```js
function sayHi() {}
sayHi.test = 5;

let bound = sayHi.bind({ name: "Alex" });
console.log(bound.test); // undefined
```

---

## **7. Tổng kết**

* `bind(context, ...args)` → tạo hàm mới với `this = context` và optional các tham số cố định.
* Partial function → bind một số tham số nhưng giữ `this` khi gọi.
* Sử dụng bind khi callback cần giữ context hoặc muốn tạo hàm với tham số cố định.

---

## **8. Thực hành**

**Bài 1**

```js
"use strict";
function f() { console.log(this); }
let user = { g: f.bind(null) };
user.g(); // null
```

**Bài 2**

```js
function f() { console.log(this.name); }
f = f.bind({name:"Alex"}).bind({name:"Anna"});
f(); // Alex
```

**Bài 3**

```js
function sayHi() { console.log(this.name); }
sayHi.test = 5;
let bound = sayHi.bind({ name: "Alex" });
console.log(bound.test); // undefined
```

</details>
