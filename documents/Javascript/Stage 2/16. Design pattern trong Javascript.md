# Design pattern trong Javascript

<details>
<summary><strong>1. Constructor Pattern trong JavaScript</strong></summary>

### 1. Constructor Pattern cơ bản

* Sử dụng **function kết hợp `new`** để tạo object.
* `this` trong hàm constructor trỏ đến **object mới**.
* Tên hàm constructor thường viết **chữ cái đầu viết hoa**.

```js
function Animal(name, leg) {
  this.name = name;
  this.leg = leg;
  this.about = function () {
    return this.name + " has " + this.leg + " legs";
  };
}

// Usage
var dog = new Animal("Dog", 4);
var bird = new Animal("Bird", 2);

console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs
```

**Nhược điểm:**

* Phương thức `about` được tạo riêng cho mỗi object → tốn bộ nhớ.
* Khó kế thừa.

---

### 2. Constructor Pattern với Prototypes

* Sử dụng `prototype` để **chia sẻ phương thức** giữa các object.
* Giúp tiết kiệm bộ nhớ và dễ mở rộng.

```js
function Animal(name, leg) {
  this.name = name;
  this.leg = leg;
}

Animal.prototype.about = function () {
  return this.name + " has " + this.leg + " legs";
};

// Usage
var dog = new Animal("Dog", 4);
var bird = new Animal("Bird", 2);

console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs
```

---

### 3. Constructor Pattern với `class`

* `class` là **cú pháp hiện đại** cho constructor pattern.
* Cấu trúc gần giống class trong C++, Java…
* **Không hoisting** (khác function).
* Có **constructor**, phương thức, getter/setter, static methods.

```js
class Animal {
  constructor(name, leg) {
    this.name = name;
    this.leg = leg;
  }

  about() {
    return this.name + " has " + this.leg + " legs";
  }
}

// Usage
var dog = new Animal("Dog", 4);
var bird = new Animal("Bird", 2);

console.log(dog.about()); // => Dog has 4 legs
console.log(bird.about()); // => Bird has 2 legs
```

**Ưu điểm:**

* Code rõ ràng, dễ đọc, gần với OOP truyền thống.
* Dễ kế thừa và mở rộng.

---

### 4. Kết luận

| Phương pháp          | Tạo phương thức | Ưu điểm                       | Nhược điểm              |
| -------------------- | --------------- | ----------------------------- | ----------------------- |
| Function + `this`    | Mỗi object      | Đơn giản                      | Tốn bộ nhớ, khó kế thừa |
| Function + Prototype | Chia sẻ         | Tiết kiệm bộ nhớ, dễ kế thừa  | Cú pháp hơi dài         |
| Class                | Chia sẻ         | Rõ ràng, hiện đại, hỗ trợ OOP | Không hoisting          |

**Tham khảo:**

* [Learning JavaScript Design Patterns](https://www.patterns.dev/posts/classic-design-patterns/)
* [Classes - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)

</details>
<details>
<summary><strong>2. Module Pattern trong JavaScript</strong></summary>

### 1. Module Pattern là gì?

* Module Pattern là **một design pattern mạnh mẽ**, giúp **đóng gói dữ liệu và phương thức**.
* Nó giúp tránh **xung đột tên biến/hàm** khi nhiều script cùng chạy trên trang web.
* Thường sử dụng **Object Literals `{}`** để expose các phương thức public.

---

### 2. Ví dụ cơ bản

```js
var countModule = (function () {
  var count = 0; // private
  var log = function (funcName) { // private
    console.log(funcName, count);
  };

  return {
    increase: function () { // public
      count++;
      log("increase");
    },
    decrease: function () { // public
      count--;
      log("decrease");
    },
    reset: function () { // public
      count = 0;
      log("reset");
    }
  };
})();

// Usage
countModule.increase(); // increase 1
countModule.increase(); // increase 2
countModule.decrease(); // decrease 1
countModule.reset();    // reset 0
```

**Giải thích:**

* `count` và `log` là **private**, chỉ truy cập bên trong module.
* Các hàm trong `return { ... }` là **public**, có thể gọi từ ngoài module.
* Cú pháp `(function() { ... })()` gọi **Immediately Invoked Function Expression (IIFE)**, tức là khai báo và gọi hàm ngay lập tức.

```js
var funcModule = function () {};
var countModule = funcModule(); // tách khai báo và gọi hàm
```

* Có thể truyền tham số khi IIFE:

```js
var countModule = (function(jQ) { ... })(jQuery);
```

---

### 3. Revealing Module Pattern

* Khắc phục nhược điểm: khó theo dõi public methods.
* **Revealing Module Pattern** cho phép **gắn trực tiếp hàm private vào object return**, giúp dễ đọc hơn.

```js
var countModule = (function () {
  var count = 0;

  var log = function (funcName) {
    console.log(funcName, count);
  };

  function increaseFunc() {
    count++;
    log("increase");
  }

  function decreaseFunc() {
    count--;
    log("decrease");
  }

  function resetFunc() {
    count = 0;
    log("reset");
  }

  return {
    increase: increaseFunc,
    decrease: decreaseFunc,
    reset: resetFunc
  };
})();

// Usage
countModule.increase(); // increase 1
countModule.decrease(); // decrease 0
countModule.reset();    // reset 0
```

**Ưu điểm:**

* Dễ theo dõi các **public methods**.
* Vẫn giữ được **private variables** bên trong module.

---

### 4. Kết luận

* Module Pattern giúp **đóng gói code, tránh xung đột**.
* Biến private không thể truy cập từ ngoài.
* Revealing Module Pattern giúp **tổ chức code rõ ràng**, dễ maintain.

**Tham khảo:**

* [Learning JavaScript Design Patterns](https://www.patterns.dev/posts/classic-design-patterns/)

</details>
<details>
<summary><strong>3. Singleton Pattern trong JavaScript</strong></summary>

### 1. Singleton Pattern là gì?

* **Singleton Pattern** giới hạn số lượng **instance của một class hoặc object** chỉ có **một duy nhất**.
* Mục đích: đảm bảo mọi phần của chương trình **sử dụng cùng một instance**, giữ **state chung**.

---

### 2. Triển khai cơ bản (Module-like)

```js
var mySingleton = (function () {
  var instance; // private

  function init() {
    var number = 0; // private variable
    return {
      setNumber: function (x) {
        number = x;
      },
      getNumber: function () {
        return number;
      }
    };
  }

  return {
    getInstance: function () {
      if (!instance) instance = init();
      return instance;
    }
  };
})();

// Usage
var instA = mySingleton.getInstance();
console.log(instA.getNumber()); // 0
instA.setNumber(10);
console.log(instA.getNumber()); // 10

var instB = mySingleton.getInstance();
console.log(instB.getNumber()); // 10

console.log(instA === instB); // true
```

**Giải thích:**

* `instance` chỉ được khởi tạo **lần đầu** gọi `getInstance()`.
* Những lần gọi sau **trả về cùng một object**.
* Mọi thay đổi state trên instance đều được **chia sẻ chung**.

---

### 3. Singleton với static property (cached property)

```js
function User() {
  // nếu đã có instance, trả về luôn
  if (typeof User.instance === "object") {
    return User.instance;
  }

  // tạo mới instance
  this.firstName = "John";
  this.lastName = "Doe";

  // cache instance
  User.instance = this;
}

// Usage
var curUser = new User();
console.log(curUser.firstName, curUser.lastName); // John Doe

var other = new User();
console.log(other.firstName, other.lastName);     // John Doe
console.log(other === curUser);                  // true
```

**Giải thích:**

* Function trong JavaScript cũng là **object**, nên có thể gán thuộc tính `User.instance`.
* Lần đầu tạo, `User.instance` là undefined → khởi tạo object mới.
* Lần tiếp theo, `User.instance` đã tồn tại → return lại instance cũ.

---

### 4. Ưu điểm

* Đảm bảo chỉ **một instance duy nhất**.
* Dễ dàng chia sẻ **state chung** giữa các phần của ứng dụng.
* Thường kết hợp với **Module Pattern** để **ẩn biến private**.

---

**Tham khảo:**

* [Learning JavaScript Design Patterns](https://www.patterns.dev/posts/classic-design-patterns/)
* [JavaScript Design Pattern: Singleton](https://refactoring.guru/design-patterns/singleton/js/example)

</details>
<details>
<summary><strong>4. PubSub (Publish / Subscribe) Pattern trong JavaScript</strong></summary>

### 1. PubSub Pattern là gì?

* **PubSub Pattern** còn gọi là **Publish / Subscribe Pattern** hay **Events Pattern**.
* Mục đích: **tách rời** phần phát sinh sự kiện (**publisher**) với phần xử lý sự kiện (**subscriber**).
* Khi một sự kiện xảy ra, các subscriber đã đăng ký sẽ được **tự động gọi**.

---

### 2. Triển khai PubSub ngắn gọn

```js
let Events = (() => {
  let events = {};

  function on(eventName, fn) {
    events[eventName] = events[eventName] || [];
    events[eventName].push(fn);
  }

  function off(eventName, fn) {
    if (events[eventName]) {
      for (let i = 0; i < events[eventName].length; i++) {
        if (events[eventName][i] === fn) {
          events[eventName].splice(i, 1);
          break;
        }
      }
    }
  }

  function emit(eventName, data) {
    if (events[eventName]) {
      events[eventName].forEach((fn) => fn(data));
    }
  }

  return { on, off, emit };
})();
```

* **`on(eventName, fn)`**: đăng ký hàm `fn` lắng nghe sự kiện `eventName`.
* **`off(eventName, fn)`**: hủy đăng ký hàm `fn` cho sự kiện `eventName`.
* **`emit(eventName, data)`**: kích hoạt sự kiện `eventName` và truyền `data` đến tất cả hàm đã đăng ký.

---

### 3. Ví dụ sử dụng

```js
// Subscriber 1
function updateItem1(data) {
  console.log("updateItem1:", data);
}

// Subscriber 2
function updateItem2(data) {
  console.log("updateItem2:", data);
}

// Đăng ký sự kiện
Events.on("addItem", updateItem1);
Events.on("addItem", updateItem2);

// Publisher phát sinh sự kiện
Events.emit("addItem", { name: "apple", quantity: 2 });

// Kết quả:
// updateItem1: { name: "apple", quantity: 2 }
// updateItem2: { name: "apple", quantity: 2 }
```

* Bạn có thể **đăng ký nhiều subscriber** cho cùng một sự kiện.
* Khi kích hoạt (`emit`), tất cả các subscriber sẽ được gọi.
* Có thể **hủy đăng ký** bằng `off` nếu không muốn nhận sự kiện nữa.

---

### 4. Giải thích cách hoạt động

* `events` là một object lưu danh sách các hàm subscriber, key là tên sự kiện.
* `on` thêm hàm vào mảng tương ứng với key.
* `off` loại bỏ hàm khỏi mảng tương ứng.
* `emit` gọi tuần tự tất cả hàm trong mảng với data được truyền vào.

---

### 5. Ưu điểm

* Tách rời phần phát sinh sự kiện và xử lý sự kiện → **code modular hơn**.
* Dễ dàng mở rộng khi có nhiều module cần lắng nghe cùng sự kiện.
* Triển khai đơn giản, dễ hiểu, dễ dùng trong cả SPA và vanilla JS.

---

**Tham khảo:**

* [JavaScript Design Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#pubsubpattern)
* [Revealing Module Pattern](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepattern)

</details>
<details>
<summary><strong>5. Method Chaining trong JavaScript</strong></summary>

### 1. Method Chaining là gì?

* **Method Chaining** (hay Function Chaining / Cascading) là kỹ thuật **gọi liên tiếp nhiều phương thức trên cùng một object**.
* Mục đích: **viết code ngắn gọn, dễ đọc, hạn chế biến tạm**.

**Ví dụ jQuery:**

```js
$(".myClass").addClass("bird").show().animate({ /* animation */ });
```

Nếu không dùng Method Chaining, code sẽ dài dòng:

```js
const $myClass = $(".myClass");
$.addClass($myClass, "bird");
$.show($myClass);
$.animate($myClass, { /* animation */ });
```

---

### 2. Ví dụ cơ bản không dùng Method Chaining

```js
class Number {
  constructor(value) {
    this.value = value;
  }
  add(value) { this.value += value; }
  sub(value) { this.value -= value; }
  mul(value) { this.value *= value; }
  div(value) { this.value /= value; }
}

let num = new Number(10);
num.add(5); // 15
num.sub(3); // 12
num.mul(2); // 24
num.div(8); // 3

console.log(num.value); // 3
```

* Nhược điểm: **phải gọi biến nhiều lần, code dài dòng**.

---

### 3. Ví dụ khi sử dụng Method Chaining

```js
class Number {
  constructor(value) {
    this.value = value;
  }
  add(value) { this.value += value; return this; }
  sub(value) { this.value -= value; return this; }
  mul(value) { this.value *= value; return this; }
  div(value) { this.value /= value; return this; }
}

let num = new Number(10);
num.add(5).sub(3).mul(2).div(8);
console.log(num.value); // 3
```

**Giải thích:**

* Chìa khóa là **`return this`** trong mỗi phương thức.
* `this` đại diện cho **object hiện tại** (`num`).
* Nhờ vậy, bạn có thể gọi liên tiếp các phương thức mà không cần lặp lại biến.

---

### 4. Ưu điểm

1. Code ngắn gọn, dễ đọc.
2. Hạn chế biến tạm và lặp lại tên object.
3. Giúp **API mượt mà** trong các thư viện hoặc framework.

---

### 5. Khi nào nên dùng

* Khi object có nhiều phương thức thao tác liên tiếp.
* Khi muốn tạo API **trực quan và dễ đọc** cho người dùng thư viện.

---

**Tham khảo:**

* [JavaScript Design Patterns: Method Chaining](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#methodchaining)
* [jQuery Chaining Documentation](https://api.jquery.com/category/chaining/)

</details>
