# üü© Day 26: Form Handling v·ªõi TypeScript + React Hook Form

---

## 1. V·∫•n ƒë·ªÅ th·ª±c t·∫ø

Form l√† n∆°i d·ªØ li·ªáu **t·ª´ user ‚Üí backend**.
Nh·ªØng v·∫•n ƒë·ªÅ ph·ªï bi·∫øn:

* Ng∆∞·ªùi d√πng nh·∫≠p d·ªØ li·ªáu sai ‚Üí crash UI.
* Backend nh·∫≠n d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá ‚Üí bug / security issue.
* State form ph·ª©c t·∫°p: nested fields, nhi·ªÅu b∆∞·ªõc, async validation.

üëâ Gi·∫£i ph√°p:
‚úÖ **React Hook Form (RHF)** ‚Üí qu·∫£n l√Ω state form hi·ªáu qu·∫£.
‚úÖ **TypeScript** ‚Üí type-safe, h·∫°n ch·∫ø bug.
‚úÖ **Schema validation (Zod/Yup)** ‚Üí chu·∫©n h√≥a d·ªØ li·ªáu.

---

## 2. Setup Project

```bash
npm install react-hook-form zod @hookform/resolvers
```

---

## 3. Form c∆° b·∫£n v·ªõi TypeScript

```tsx
import React from "react";
import { useForm } from "react-hook-form";

// 1. ƒê·ªãnh nghƒ©a type cho d·ªØ li·ªáu form
type LoginForm = {
  email: string;
  password: string;
};

export default function Login() {
  // 2. Kh·ªüi t·∫°o React Hook Form v·ªõi type an to√†n
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginForm>();

  // 3. Submit handler
  const onSubmit = (data: LoginForm) => {
    console.log("‚úÖ Form Data:", data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Email */}
      <input
        {...register("email", { required: "Email l√† b·∫Øt bu·ªôc" })}
        placeholder="Email"
      />
      {errors.email && <p>{errors.email.message}</p>}

      {/* Password */}
      <input
        type="password"
        {...register("password", { required: "M·∫≠t kh·∫©u b·∫Øt bu·ªôc" })}
        placeholder="Password"
      />
      {errors.password && <p>{errors.password.message}</p>}

      <button type="submit">ƒêƒÉng nh·∫≠p</button>
    </form>
  );
}
```

üëâ TypeScript s·∫Ω c·∫£nh b√°o n·∫øu thi·∫øu field.

---

## 4. K·∫øt h·ª£p v·ªõi Zod Validation

```tsx
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";

// 1. Schema validation
const LoginSchema = z.object({
  email: z.string().email("Email kh√¥ng h·ª£p l·ªá"),
  password: z.string().min(6, "M·∫≠t kh·∫©u √≠t nh·∫•t 6 k√Ω t·ª±"),
});

// 2. Infer type
type LoginForm = z.infer<typeof LoginSchema>;

export default function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginForm>({
    resolver: zodResolver(LoginSchema),
  });

  const onSubmit = (data: LoginForm) => {
    console.log("‚úÖ Validated Data:", data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register("email")} placeholder="Email" />
      {errors.email && <p>{errors.email.message}</p>}

      <input type="password" {...register("password")} placeholder="Password" />
      {errors.password && <p>{errors.password.message}</p>}

      <button type="submit">ƒêƒÉng nh·∫≠p</button>
    </form>
  );
}
```

---

## 5. Enterprise Use Cases

### a) Form ph·ª©c t·∫°p (nested objects)

```ts
const UserSchema = z.object({
  name: z.string(),
  address: z.object({
    city: z.string(),
    zipcode: z.string(),
  }),
});
type UserForm = z.infer<typeof UserSchema>;
```

### b) Async Validation (check email t·ªìn t·∫°i)

```tsx
<input
  {...register("email", {
    validate: async (value) => {
      const exists = await fetch(`/api/check-email?email=${value}`).then((r) =>
        r.json()
      );
      return exists ? "Email ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω" : true;
    },
  })}
/>
```

### c) K·∫øt h·ª£p v·ªõi API Response Type

```ts
type ApiResponse<T> =
  | { status: "success"; data: T }
  | { status: "error"; message: string };

async function submitForm(data: LoginForm): Promise<ApiResponse<LoginForm>> {
  try {
    const res = await fetch("/api/login", {
      method: "POST",
      body: JSON.stringify(data),
    });
    return { status: "success", data: await res.json() };
  } catch (e) {
    return { status: "error", message: "Login failed" };
  }
}
```

---

## 6. Advanced Usage ‚Äî Build Complex & Accessible Forms

### 6.1 Accessibility (A11y)

```tsx
<label htmlFor="email">Email</label>
<input
  id="email"
  type="email"
  aria-invalid={errors.email ? "true" : "false"}
  aria-describedby="email-error"
  {...register("email", { required: "Email l√† b·∫Øt bu·ªôc" })}
/>
{errors.email && <span id="email-error">{errors.email.message}</span>}
```

---

### 6.2 Wizard Form / Funnel

```tsx
function WizardForm() {
  const [step, setStep] = useState(1);
  const { register, handleSubmit } = useForm();

  return (
    <form onSubmit={handleSubmit(console.log)}>
      {step === 1 && (
        <>
          <input {...register("name")} placeholder="Name" />
          <button type="button" onClick={() => setStep(2)}>Next</button>
        </>
      )}
      {step === 2 && (
        <>
          <input {...register("email")} placeholder="Email" />
          <button type="submit">Submit</button>
        </>
      )}
    </form>
  );
}
```

---

### 6.3 Smart Form Component

```tsx
function InputField({ label, name, register, error }: any) {
  return (
    <div>
      <label>{label}</label>
      <input {...register(name)} />
      {error && <span>{error.message}</span>}
    </div>
  );
}
```

---

### 6.4 Error Messages + i18n

```tsx
<input {...register("username", { required: "‚ö†Ô∏è Username required" })} />
{errors.username && <p role="alert">{errors.username.message}</p>}
```

---

### 6.5 Connect Form (FormProvider)

```tsx
import { FormProvider, useForm, useFormContext } from "react-hook-form";

function ChildInput({ name }: { name: string }) {
  const { register } = useFormContext();
  return <input {...register(name)} />;
}

export default function ParentForm() {
  const methods = useForm();
  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(console.log)}>
        <ChildInput name="email" />
        <button type="submit">Submit</button>
      </form>
    </FormProvider>
  );
}
```

---

### 6.6 Performance Optimization

```tsx
const Input = React.memo(({ name }: { name: string }) => {
  const { register } = useFormContext();
  return <input {...register(name)} />;
});
```

---

### 6.7 Controlled + Uncontrolled

```tsx
<Controller
  control={control}
  name="dob"
  render={({ field }) => (
    <DatePicker selected={field.value} onChange={field.onChange} />
  )}
/>
```

---

### 6.8 Custom Hook with Resolver

```tsx
const schema = z.object({ email: z.string().email() });
function useLoginForm() {
  return useForm({ resolver: zodResolver(schema) });
}
```

---

### 6.9 Virtualized Lists

```tsx
import { FixedSizeList } from "react-window";

function BigForm({ fields }: { fields: string[] }) {
  return (
    <FixedSizeList height={400} itemCount={fields.length} itemSize={35}>
      {({ index, style }) => (
        <div style={style}>
          <input type="checkbox" name={fields[index]} />
          {fields[index]}
        </div>
      )}
    </FixedSizeList>
  );
}
```

---

### 6.10 Testing Form

```tsx
test("shows error when email is empty", async () => {
  render(<MyForm />);
  fireEvent.submit(screen.getByRole("button"));
  expect(await screen.findByText(/Email is required/i)).toBeInTheDocument();
});
```

---

### 6.11 Transform and Parse

```tsx
const onSubmit = (data: any) => {
  const payload = {
    ...data,
    dob: new Date(data.dob).toISOString(),
  };
  fetch("/api/users", { method: "POST", body: JSON.stringify(payload) });
};
```

---

## 7. Mini Project ‚Äî Registration Form

Y√™u c·∫ßu:

* Input: `username`, `email`, `password`, `confirmPassword`.
* Validate v·ªõi Zod.
* Submit data l√™n API (fake).
* Show loading + success/error.
* C√≥ A11y, i18n error, performance t·ªëi ∆∞u.

---

## 8. B√†i t·∫≠p

### Level 1

* T·∫°o contact form (name, email, message) c√≥ validate required.

### Level 2

* Th√™m validation Zod: email h·ª£p l·ªá, message ‚â• 10 k√Ω t·ª±.

### Level 3 (Mini Project Enterprise)

* Registration form ƒë·∫ßy ƒë·ªß:

  * Wizard (multi-step).
  * Smart Input + FormProvider.
  * i18n error messages.
  * Submit l√™n API gi·∫£ l·∫≠p.
  * Test v·ªõi React Testing Library.
  * Optimize khi c√≥ 100+ fields.

---


####  Exercises Solutions

## üîπ Level 1

### 1. T·∫°o form ƒëƒÉng k√Ω (register form) v·ªõi c√°c tr∆∞·ªùng c∆° b·∫£n

```tsx
import React from "react";
import { useForm } from "react-hook-form";

// ƒê·ªãnh nghƒ©a ki·ªÉu d·ªØ li·ªáu cho form
type FormData = {
  username: string;
  email: string;
  password: string;
};

export default function RegisterForm() {
  // useForm hook qu·∫£n l√Ω form
  const { register, handleSubmit, formState: { errors } } = useForm<FormData>();

  // H√†m x·ª≠ l√Ω khi submit
  const onSubmit = (data: FormData) => {
    console.log("Submitted:", data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Input username */}
      <input
        placeholder="Username"
        {...register("username", { required: "Username is required" })}
      />
      {errors.username && <p>{errors.username.message}</p>}

      {/* Input email */}
      <input
        placeholder="Email"
        {...register("email", { required: "Email required", pattern: /^\S+@\S+$/i })}
      />
      {errors.email && <p>{errors.email.message}</p>}

      {/* Input password */}
      <input
        type="password"
        placeholder="Password"
        {...register("password", { minLength: { value: 6, message: "At least 6 chars" } })}
      />
      {errors.password && <p>{errors.password.message}</p>}

      <button type="submit">Register</button>
    </form>
  );
}
```

‚úÖ ƒê√¢y l√† form c∆° b·∫£n, ch∆∞a c√≥ logic n√¢ng cao.

---

## üîπ Level 2

### 2. T·∫°o **multi-step form (Wizard form)**

üëâ Y√™u c·∫ßu: ng∆∞·ªùi d√πng ƒëi·ªÅn theo t·ª´ng b∆∞·ªõc (Step 1 ‚Üí Step 2 ‚Üí Review).

```tsx
import React, { useState } from "react";
import { useForm, FormProvider } from "react-hook-form";

type FormData = {
  name: string;
  email: string;
  age: number;
};

export default function WizardForm() {
  const methods = useForm<FormData>();
  const [step, setStep] = useState(1);

  const onSubmit = (data: FormData) => {
    console.log("Final Data:", data);
  };

  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(onSubmit)}>
        {step === 1 && (
          <div>
            <input placeholder="Name" {...methods.register("name", { required: true })} />
            <button type="button" onClick={() => setStep(2)}>Next</button>
          </div>
        )}

        {step === 2 && (
          <div>
            <input placeholder="Email" {...methods.register("email", { required: true })} />
            <input type="number" placeholder="Age" {...methods.register("age", { min: 18 })} />
            <button type="button" onClick={() => setStep(1)}>Back</button>
            <button type="submit">Submit</button>
          </div>
        )}
      </form>
    </FormProvider>
  );
}
```

‚úÖ ƒê√¢y l√† form **multi-step (Wizard form)** v·ªõi ƒëi·ªÅu h∆∞·ªõng gi·ªØa c√°c b∆∞·ªõc.

---

## üîπ Level 3

### 3. T·∫°o **Form ph·ª©c t·∫°p + A11y + Error Handling n√¢ng cao + Performance**

üëâ ƒê√¢y l√† **Enterprise Use Case**: Form ƒëƒÉng k√Ω s·ª± ki·ªán v·ªõi nhi·ªÅu tr∆∞·ªùng, validation, error message, field conditionally rendering, v√† s·ª≠ d·ª•ng `FormProvider` ƒë·ªÉ t·ªëi ∆∞u performance.

```tsx
import React from "react";
import { useForm, FormProvider, useFormContext } from "react-hook-form";

type EventFormData = {
  fullName: string;
  email: string;
  role: "student" | "developer" | "manager";
  portfolio?: string;
  agree: boolean;
};

// Component input ri√™ng ƒë·ªÉ t√°i s·ª≠ d·ª•ng
function InputField({ name, label }: { name: keyof EventFormData; label: string }) {
  const { register, formState: { errors } } = useFormContext<EventFormData>();

  return (
    <div>
      <label htmlFor={name}>{label}</label>
      <input id={name} {...register(name, { required: `${label} is required` })} />
      {errors[name] && <p style={{ color: "red" }}>{errors[name]?.message as string}</p>}
    </div>
  );
}

export default function EventRegisterForm() {
  const methods = useForm<EventFormData>();
  const { watch, handleSubmit } = methods;

  // L·∫•y gi√° tr·ªã role ƒë·ªÉ hi·ªÉn th·ªã conditional field
  const role = watch("role");

  const onSubmit = (data: EventFormData) => {
    console.log("Event Registration Data:", data);
  };

  return (
    <FormProvider {...methods}>
      <form onSubmit={handleSubmit(onSubmit)}>
        {/* H·ªç t√™n */}
        <InputField name="fullName" label="Full Name" />

        {/* Email */}
        <InputField name="email" label="Email" />

        {/* Select role */}
        <label>Role</label>
        <select {...methods.register("role", { required: "Role is required" })}>
          <option value="">Select your role</option>
          <option value="student">Student</option>
          <option value="developer">Developer</option>
          <option value="manager">Manager</option>
        </select>

        {/* Conditional field: Portfolio (ch·ªâ hi·ªán khi ch·ªçn developer) */}
        {role === "developer" && (
          <InputField name="portfolio" label="Portfolio URL" />
        )}

        {/* Checkbox ƒë·ªìng √Ω */}
        <label>
          <input type="checkbox" {...methods.register("agree", { required: "You must agree" })} />
          I agree to terms
        </label>

        <button type="submit">Register</button>
      </form>
    </FormProvider>
  );
}
```

### üè¢ Enterprise Features c√≥ trong code:

* **Re-usable input component** (`InputField`)
* **FormProvider** ‚Üí gi·∫£m re-render, tƒÉng performance
* **Conditional rendering** (portfolio ch·ªâ hi·ªán khi role = developer)
* **Accessible labels + error messages** ‚Üí h·ªó tr·ª£ screen reader
* **Validation + Error handling** ‚Üí UX t·ªët



---


### Testing Complex Form (Enterprise Use Case)

## ‚úÖ C√†i ƒë·∫∑t (n·∫øu ch·∫°y project th·∫≠t)

```bash
npm install @testing-library/react @testing-library/jest-dom @testing-library/user-event jest
```

---

## üìå Test Code: `EventRegisterForm.test.tsx`

```tsx
import React from "react";
import { render, screen, fireEvent } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import EventRegisterForm from "./EventRegisterForm";

// Helper function ƒëi·ªÅn input
const fillInput = async (label: string, value: string) => {
  const input = screen.getByLabelText(label);
  await userEvent.type(input, value);
};

describe("EventRegisterForm", () => {
  test("renders all required fields", () => {
    render(<EventRegisterForm />);

    // Ki·ªÉm tra label
    expect(screen.getByLabelText(/Full Name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/Role/i)).toBeInTheDocument();
    expect(screen.getByText(/I agree to terms/i)).toBeInTheDocument();
  });

  test("shows validation errors when submitting empty form", async () => {
    render(<EventRegisterForm />);

    fireEvent.click(screen.getByRole("button", { name: /Register/i }));

    expect(await screen.findByText(/Full Name is required/i)).toBeInTheDocument();
    expect(await screen.findByText(/Email is required/i)).toBeInTheDocument();
    expect(await screen.findByText(/Role is required/i)).toBeInTheDocument();
    expect(await screen.findByText(/You must agree/i)).toBeInTheDocument();
  });

  test("conditionally renders Portfolio field when role is Developer", async () => {
    render(<EventRegisterForm />);

    // Tr∆∞·ªõc khi ch·ªçn role Developer
    expect(screen.queryByLabelText(/Portfolio URL/i)).not.toBeInTheDocument();

    // Ch·ªçn Developer
    fireEvent.change(screen.getByLabelText(/Role/i), { target: { value: "developer" } });

    // B√¢y gi·ªù ph·∫£i hi·ªán Portfolio
    expect(await screen.findByLabelText(/Portfolio URL/i)).toBeInTheDocument();
  });

  test("submits form with valid data", async () => {
    render(<EventRegisterForm />);

    await fillInput("Full Name", "Alice Johnson");
    await fillInput("Email", "alice@example.com");
    fireEvent.change(screen.getByLabelText(/Role/i), { target: { value: "student" } });
    fireEvent.click(screen.getByRole("checkbox", { name: /I agree to terms/i }));

    fireEvent.click(screen.getByRole("button", { name: /Register/i }));

    // V√¨ m√¨nh console.log data trong form, n√™n test ch·ªâ c·∫ßn check l√† kh√¥ng c√≥ l·ªói hi·ªÉn th·ªã
    expect(screen.queryByText(/is required/i)).not.toBeInTheDocument();
  });
});
```

---

## üìå Gi·∫£i th√≠ch t·ª´ng ph·∫ßn

* `render(<EventRegisterForm />)` ‚Üí render form ƒë·ªÉ test.
* `screen.getByLabelText("Full Name")` ‚Üí truy c·∫≠p input qua label (h·ªó tr·ª£ **Accessibility A11y**).
* `fireEvent.click(button)` ho·∫∑c `userEvent.type(input, value)` ‚Üí m√¥ ph·ªèng h√†nh vi ng∆∞·ªùi d√πng.
* `expect(...).toBeInTheDocument()` ‚Üí assert r·∫±ng ph·∫ßn t·ª≠ c√≥ hi·ªÉn th·ªã.
* Test bao g·ªìm:

  1. **Render field c∆° b·∫£n**
  2. **Validation error khi submit tr·ªëng**
  3. **Conditional field Portfolio khi ch·ªçn Developer**
  4. **Submit h·ª£p l·ªá kh√¥ng b√°o l·ªói**

---

üëâ ƒê√¢y l√† **m·ªôt b·ªô test chu·∫©n enterprise**:

* Ki·ªÉm tra **UX** (hi·ªÉn th·ªã l·ªói ƒë√∫ng)
* Ki·ªÉm tra **Logic** (conditional field ho·∫°t ƒë·ªông)
* Ki·ªÉm tra **Form submit** (valid data kh√¥ng l·ªói)

---

### Performance Testing with `FormProvider`

## üìå T·∫°i sao c·∫ßn?

* Form l·ªõn c√≥ nhi·ªÅu input ‚Üí n·∫øu kh√¥ng t·ªëi ∆∞u th√¨ m·ªói l·∫ßn g√µ **1 input ‚Üí to√†n b·ªô form re-render** üò±.
* `React Hook Form` + `FormProvider` cho ph√©p chia nh·ªè input ‚Üí ch·ªâ input n√†o thay ƒë·ªïi m·ªõi re-render.

---

## üìå Component Demo ‚Äì `BigForm.tsx`

```tsx
import React from "react";
import { useForm, FormProvider, useFormContext } from "react-hook-form";

type FormValues = {
  firstName: string;
  lastName: string;
  email: string;
  bio: string;
};

let renderCount = { firstName: 0, lastName: 0, email: 0, bio: 0 };

const InputField = ({ name, label }: { name: keyof FormValues; label: string }) => {
  const { register } = useFormContext<FormValues>();
  renderCount[name]++;

  return (
    <div>
      <label>{label}</label>
      <input {...register(name)} />
      <p data-testid={`render-${name}`}>Render count: {renderCount[name]}</p>
    </div>
  );
};

export default function BigForm() {
  const methods = useForm<FormValues>();
  const onSubmit = (data: FormValues) => console.log("‚úÖ Submitted:", data);

  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(onSubmit)}>
        <InputField name="firstName" label="First Name" />
        <InputField name="lastName" label="Last Name" />
        <InputField name="email" label="Email" />
        <InputField name="bio" label="Bio" />
        <button type="submit">Submit</button>
      </form>
    </FormProvider>
  );
}
```

---

## üìå Test File ‚Äì `BigForm.test.tsx`

```tsx
import React from "react";
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import BigForm from "./BigForm";

describe("BigForm Performance", () => {
  test("only re-renders the field that changes", async () => {
    render(<BigForm />);

    const firstNameInput = screen.getByLabelText(/First Name/i);
    const lastNameInput = screen.getByLabelText(/Last Name/i);

    // G√µ v√†o First Name
    await userEvent.type(firstNameInput, "Alice");

    // Ki·ªÉm tra render count
    const firstNameRender = screen.getByTestId("render-firstName");
    const lastNameRender = screen.getByTestId("render-lastName");

    // üëâ First Name render nhi·ªÅu l·∫ßn do typing
    expect(parseInt(firstNameRender.textContent!.replace(/\D/g, ""))).toBeGreaterThan(1);

    // üëâ Last Name ch∆∞a b·ªã re-render
    expect(lastNameRender).toHaveTextContent("Render count: 1");

    // G√µ v√†o Last Name
    await userEvent.type(lastNameInput, "Johnson");

    // B√¢y gi·ªù Last Name ph·∫£i tƒÉng render
    expect(lastNameRender.textContent).toMatch(/Render count: [2-9]/);
  });
});
```

---

## üìå Gi·∫£i th√≠ch

* `renderCount` theo d√µi s·ªë l·∫ßn m·ªói field render.
* Khi g√µ v√†o **First Name** ‚Üí ch·ªâ `firstName` re-render, c√°c field kh√°c kh√¥ng b·ªã ·∫£nh h∆∞·ªüng.
* Test s·∫Ω **fail** n·∫øu form b·ªã re-render to√†n b·ªô ‚Üí nghƒ©a l√† dev code ch∆∞a t·ªëi ∆∞u.

---

üëâ ƒê√¢y l√† c√°ch enterprise ƒë·∫£m b·∫£o **form scale l√™n h√†ng trƒÉm field v·∫´n ch·∫°y m∆∞·ª£t**, kh√¥ng gi·∫≠t lag.

---


### Virtualized Form with `react-window`

## üìå V·∫•n ƒë·ªÅ

* N·∫øu form c√≥ **1000+ input**, m·ªói l·∫ßn render s·∫Ω **gi·∫≠t & ch·∫≠m**.
* Gi·∫£i ph√°p: **virtualization** ‚Üí ch·ªâ render field n·∫±m trong viewport.

---

## üìå C√†i ƒë·∫∑t

```bash
npm install react-window
```

---

## üìå Code Demo ‚Äì `VirtualizedForm.tsx`

```tsx
import React from "react";
import { useForm, FormProvider, useFormContext } from "react-hook-form";
import { FixedSizeList as List } from "react-window";

type FormValues = {
  [key: `field_${number}`]: string;
};

const TOTAL_FIELDS = 1000;

// Component input v·ªõi RHF
const VirtualInput = ({ index, style }: { index: number; style: React.CSSProperties }) => {
  const { register } = useFormContext<FormValues>();
  const name = `field_${index}` as const;

  return (
    <div style={style}>
      <label>{`Field ${index}`}</label>
      <input {...register(name)} placeholder={`Type something for field ${index}`} />
    </div>
  );
};

export default function VirtualizedForm() {
  const methods = useForm<FormValues>();
  const onSubmit = (data: FormValues) => console.log("‚úÖ Submitted:", data);

  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(onSubmit)} style={{ height: 400 }}>
        {/* List ·∫£o h√≥a */}
        <List
          height={400} // chi·ªÅu cao container
          itemCount={TOTAL_FIELDS}
          itemSize={50} // chi·ªÅu cao m·ªói item
          width={400}
        >
          {({ index, style }) => <VirtualInput index={index} style={style} />}
        </List>

        <button type="submit">Submit</button>
      </form>
    </FormProvider>
  );
}
```

---

## üìå Gi·∫£i th√≠ch

* `react-window` ch·ªâ render **c√°c item ƒëang nh√¨n th·∫•y** (VD: viewport 400px ‚Üí ch·ªâ render 8‚Äì10 field).
* Khi scroll, item c≈© b·ªã unmount, item m·ªõi mount.
* `register` c·ªßa RHF v·∫´n ho·∫°t ƒë·ªông v√¨ input mount v√†o form context.

---

## üìå Testing Performance

```tsx
import React from "react";
import { render, screen } from "@testing-library/react";
import VirtualizedForm from "./VirtualizedForm";

describe("VirtualizedForm", () => {
  test("renders only visible fields initially", () => {
    render(<VirtualizedForm />);

    // Ch·ªâ th·∫•y c√°c field ƒë·∫ßu ti√™n
    expect(screen.getByLabelText("Field 0")).toBeInTheDocument();
    expect(screen.getByLabelText("Field 5")).toBeInTheDocument();

    // Field 999 ch∆∞a render
    expect(screen.queryByLabelText("Field 999")).toBeNull();
  });
});
```

---

## üìå Enterprise Use Case

* **Data-heavy forms**: onboarding 50+ steps.
* **Dynamic survey builder**: 200‚Äì500 c√¢u h·ªèi.
* **Admin tools**: CRUD v·ªõi b·∫£ng h√†ng ng√†n input editable.

üëâ V·ªõi `react-window` + `RHF`, form v·∫´n **m∆∞·ª£t** ngay c·∫£ khi h√†ng ng√†n field.

---

# üöÄ Custom Hook + Custom Resolver trong React Hook Form

## üìå V·∫•n ƒë·ªÅ

* `react-hook-form` c√≥ `resolver` (Zod, Yup, Joi, Vest‚Ä¶) nh∆∞ng ƒë√¥i khi **doanh nghi·ªáp c√≥ logic ri√™ng**.
* VD: Password ph·∫£i **‚â• 6 k√Ω t·ª±**, nh∆∞ng n·∫øu ch·ª©a `admin` th√¨ **b·∫Øt bu·ªôc ‚â• 10 k√Ω t·ª±**.
* Ho·∫∑c b·∫°n mu·ªën validate b·∫±ng **API call** (VD: check username tr√πng).

üëâ L√∫c n√†y ta vi·∫øt **Custom Resolver**.

---

## üìå T·∫°o Custom Resolver

```tsx
import React from "react";
import { useForm, Resolver } from "react-hook-form";

// Ki·ªÉu d·ªØ li·ªáu form
type RegisterForm = {
  username: string;
  password: string;
};

// Custom resolver
const customResolver: Resolver<RegisterForm> = async (values) => {
  const errors: any = {};

  // Rule 1: username required
  if (!values.username) {
    errors.username = { type: "required", message: "Username l√† b·∫Øt bu·ªôc" };
  } else if (values.username.length < 4) {
    errors.username = { type: "minLength", message: "Username t·ªëi thi·ªÉu 4 k√Ω t·ª±" };
  }

  // Rule 2: password ph·ª©c t·∫°p h∆°n
  if (!values.password) {
    errors.password = { type: "required", message: "Password l√† b·∫Øt bu·ªôc" };
  } else if (values.password.includes("admin") && values.password.length < 10) {
    errors.password = { type: "custom", message: "Password ch·ª©a 'admin' ph·∫£i ‚â• 10 k√Ω t·ª±" };
  } else if (values.password.length < 6) {
    errors.password = { type: "minLength", message: "Password t·ªëi thi·ªÉu 6 k√Ω t·ª±" };
  }

  // Tr·∫£ v·ªÅ k·∫øt qu·∫£
  return {
    values: Object.keys(errors).length ? {} : values,
    errors,
  };
};

export default function RegisterForm() {
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<RegisterForm>({ resolver: customResolver });

  const onSubmit = (data: RegisterForm) => console.log("‚úÖ Valid Data:", data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input {...register("username")} placeholder="Username" />
        {errors.username && <p>{errors.username.message}</p>}
      </div>

      <div>
        <input type="password" {...register("password")} placeholder="Password" />
        {errors.password && <p>{errors.password.message}</p>}
      </div>

      <button type="submit">ƒêƒÉng k√Ω</button>
    </form>
  );
}
```

---

## üìå Custom Hook ƒë·ªÉ Reuse Logic

```tsx
import { useForm, Resolver } from "react-hook-form";

type AnyForm = Record<string, any>;

// T·∫°o hook t√°i s·ª≠ d·ª•ng
export function useCustomForm<T extends AnyForm>(resolver: Resolver<T>) {
  return useForm<T>({ resolver, mode: "onChange" });
}
```

üëâ Gi·ªù ta c√≥ th·ªÉ d√πng `useCustomForm` v·ªõi b·∫•t k·ª≥ resolver n√†o.

---

## üìå Enterprise Use Case

1. **Password Policy**: c√¥ng ty y√™u c·∫ßu password ph·∫£i match regex ri√™ng.
2. **Dynamic Business Rule**: d·ª±a v√†o c·∫•u h√¨nh DB ‚Üí rule thay ƒë·ªïi runtime.
3. **External Service Validation**: g·ªçi API validate s·ªë CMND / s·ªë ƒëi·ªán tho·∫°i.
4. **Multi-language Error**: resolver c√≥ th·ªÉ tr·∫£ l·ªói theo locale (EN, VN, JP).

---

## üìå Mini Project: Username Check b·∫±ng API (Fake)

```tsx
const usernameResolver: Resolver<{ username: string }> = async (values) => {
  const errors: any = {};
  if (!values.username) {
    errors.username = { type: "required", message: "Username l√† b·∫Øt bu·ªôc" };
  } else {
    // Fake API check
    const exists = await new Promise<boolean>((resolve) =>
      setTimeout(() => resolve(values.username === "admin"), 500)
    );
    if (exists) {
      errors.username = { type: "conflict", message: "Username ƒë√£ t·ªìn t·∫°i" };
    }
  }
  return { values: Object.keys(errors).length ? {} : values, errors };
};
```

---

üëâ V·ªõi c√°ch n√†y, b·∫°n **kh√¥ng b·ªã ph·ª• thu·ªôc** v√†o Zod/Yup m√† v·∫´n c√≥ form type-safe, validation linh ho·∫°t, t√≠ch h·ª£p API, ƒë√∫ng chu·∫©n enterprise.

---

# ‚ö° Controlled + Uncontrolled Components trong React Hook Form

## 1. üìå V·∫•n ƒë·ªÅ

* `react-hook-form` m·∫∑c ƒë·ªãnh t·ªëi ∆∞u v·ªõi **uncontrolled components** (`<input {...register("name")} />`).
* Nh∆∞ng nhi·ªÅu UI libraries (MUI, AntD, Chakra‚Ä¶) l·∫°i cung c·∫•p **controlled components** (`<TextField value={...} onChange={...} />`).
* N·∫øu ta kh√¥ng x·ª≠ l√Ω ƒë√∫ng ‚Üí form kh√¥ng sync state, m·∫•t performance, ho·∫∑c warning.

üëâ Gi·∫£i ph√°p: D√πng **Controller** c·ªßa RHF ƒë·ªÉ bridge controlled ‚Üî uncontrolled.

---

## 2. üìå V√≠ d·ª• c∆° b·∫£n v·ªõi MUI `TextField`

```tsx
import React from "react";
import { useForm, Controller } from "react-hook-form";
import TextField from "@mui/material/TextField";

type FormValues = {
  email: string;
};

export default function ControlledExample() {
  const { control, handleSubmit } = useForm<FormValues>({
    defaultValues: { email: "" },
  });

  const onSubmit = (data: FormValues) => console.log("‚úÖ Data:", data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Controlled field */}
      <Controller
        name="email"
        control={control}
        rules={{ required: "Email l√† b·∫Øt bu·ªôc" }}
        render={({ field, fieldState }) => (
          <TextField
            {...field}
            label="Email"
            error={!!fieldState.error}
            helperText={fieldState.error?.message}
          />
        )}
      />

      <button type="submit">Submit</button>
    </form>
  );
}
```

üëâ `Controller` s·∫Ω:

* Gi·ªØ value v√† onChange sync v·ªõi RHF.
* Truy·ªÅn error state xu·ªëng UI library.

---

## 3. üìå K·∫øt h·ª£p Controlled + Uncontrolled

V√≠ d·ª•:

* `username` d√πng uncontrolled input (nh·∫π, nhanh).
* `email` d√πng controlled `MUI TextField` (c·∫ßn UI lib).

```tsx
type FormValues = {
  username: string;
  email: string;
};

export default function MixedForm() {
  const { register, handleSubmit, control } = useForm<FormValues>();

  const onSubmit = (data: FormValues) => console.log("‚úÖ Mixed Data:", data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Uncontrolled */}
      <input {...register("username", { required: "Username l√† b·∫Øt bu·ªôc" })} placeholder="Username" />

      {/* Controlled */}
      <Controller
        name="email"
        control={control}
        render={({ field }) => <TextField {...field} label="Email" />}
      />

      <button type="submit">Submit</button>
    </form>
  );
}
```

üëâ ƒê√¢y l√† m√¥ h√¨nh **enterprise th·ª±c t·∫ø**:

* M·ªôt s·ªë input d√πng controlled v√¨ UI lib b·∫Øt bu·ªôc.
* C√°c input ƒë∆°n gi·∫£n (text, checkbox) gi·ªØ uncontrolled ƒë·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng.

---

## 4. üìå Enterprise Use Cases

1. **MUI / Ant Design Forms**

   * D√πng `Controller` ƒë·ªÉ wrap `Select`, `DatePicker`, `Autocomplete`.

2. **Performance Optimization**

   * Ch·ªâ controlled nh·ªØng field th·∫≠t s·ª± c·∫ßn (`react-select`, `rich text editor`).
   * C√°c tr∆∞·ªùng text c∆° b·∫£n d√πng uncontrolled.

3. **Dynamic Forms**

   * M·ªôt s·ªë field ƒë∆∞·ª£c render runtime (API ‚Üí config form).
   * D√πng controlled ƒë·ªÉ inject logic ph·ª©c t·∫°p (validation async, dependent fields).

---

## 5. üìå Mini Project: Mixed Form (Login + Options)

```tsx
type LoginForm = {
  username: string;
  email: string;
  remember: boolean;
};

export default function MixedLoginForm() {
  const { register, handleSubmit, control } = useForm<LoginForm>();

  const onSubmit = (data: LoginForm) => console.log("‚úÖ Mixed Form:", data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Uncontrolled */}
      <input {...register("username")} placeholder="Username" />

      {/* Controlled (MUI) */}
      <Controller
        name="email"
        control={control}
        render={({ field }) => <TextField {...field} label="Email" />}
      />

      {/* Checkbox uncontrolled */}
      <label>
        <input type="checkbox" {...register("remember")} /> Remember Me
      </label>

      <button type="submit">Login</button>
    </form>
  );
}
```

---

üëâ T√≥m l·∫°i:

* D√πng **uncontrolled** cho t·ªëc ƒë·ªô.
* D√πng **Controller** khi c·∫ßn controlled UI components.
* C√≥ th·ªÉ mix c·∫£ hai trong c√πng form ‚Üí linh ho·∫°t + t·ªëi ∆∞u.

---


# ‚ö° Wizard Form / Funnel Form v·ªõi React Hook Form

## 1. üìå V·∫•n ƒë·ªÅ

* Form d√†i ‚Üí UX k√©m, d·ªÖ b·ªè cu·ªôc.
* C·∫ßn chia th√†nh nhi·ªÅu **step (wizard)**: th√¥ng tin c√° nh√¢n ‚Üí ƒë·ªãa ch·ªâ ‚Üí thanh to√°n.
* Nh∆∞ng:

  * L√†m sao gi·ªØ d·ªØ li·ªáu khi chuy·ªÉn b∆∞·ªõc?
  * Validation t·ª´ng b∆∞·ªõc nh∆∞ th·∫ø n√†o?
  * Hi·ªáu nƒÉng khi c√≥ nhi·ªÅu field?

üëâ Gi·∫£i ph√°p: **FormProvider** + custom Wizard logic.

---

## 2. üìå C·∫•u tr√∫c Wizard Form

### `Wizard.tsx` (logic t·ªïng)

```tsx
import React, { useState } from "react";
import { FormProvider, useForm } from "react-hook-form";

type FormValues = {
  name: string;
  email: string;
  address: string;
  payment: string;
};

const steps = ["Info", "Address", "Payment"];

export default function Wizard() {
  const methods = useForm<FormValues>({
    defaultValues: {
      name: "",
      email: "",
      address: "",
      payment: ""
    }
  });

  const [step, setStep] = useState(0);

  const nextStep = async () => {
    const valid = await methods.trigger(); // validate current step
    if (valid) setStep((s) => s + 1);
  };

  const prevStep = () => setStep((s) => s - 1);

  const onSubmit = (data: FormValues) => {
    console.log("‚úÖ Final Submit:", data);
  };

  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(onSubmit)}>
        <h2>Step {step + 1}: {steps[step]}</h2>

        {step === 0 && <InfoStep />}
        {step === 1 && <AddressStep />}
        {step === 2 && <PaymentStep />}

        <div style={{ marginTop: 20 }}>
          {step > 0 && <button type="button" onClick={prevStep}>Back</button>}
          {step < steps.length - 1 && <button type="button" onClick={nextStep}>Next</button>}
          {step === steps.length - 1 && <button type="submit">Submit</button>}
        </div>
      </form>
    </FormProvider>
  );
}
```

---

### C√°c Step Components

üìç Step 1: **InfoStep.tsx**

```tsx
import { useFormContext } from "react-hook-form";

export function InfoStep() {
  const { register } = useFormContext();
  return (
    <div>
      <input {...register("name", { required: "Name required" })} placeholder="Name" />
      <input {...register("email", { required: "Email required" })} placeholder="Email" />
    </div>
  );
}
```

üìç Step 2: **AddressStep.tsx**

```tsx
import { useFormContext } from "react-hook-form";

export function AddressStep() {
  const { register } = useFormContext();
  return (
    <div>
      <input {...register("address", { required: "Address required" })} placeholder="Address" />
    </div>
  );
}
```

üìç Step 3: **PaymentStep.tsx**

```tsx
import { useFormContext } from "react-hook-form";

export function PaymentStep() {
  const { register } = useFormContext();
  return (
    <div>
      <select {...register("payment", { required: "Payment required" })}>
        <option value="">Select payment</option>
        <option value="credit">Credit Card</option>
        <option value="paypal">Paypal</option>
      </select>
    </div>
  );
}
```

---

## 3. üìå ∆Øu ƒëi·ªÉm

* **FormProvider**: share state cho t·∫•t c·∫£ steps.
* **trigger()**: ch·ªâ validate fields trong step hi·ªán t·∫°i.
* **handleSubmit**: gom to√†n b·ªô data cu·ªëi c√πng.

---

## 4. üìå Enterprise Use Cases

1. **Checkout Funnel** (Cart ‚Üí Address ‚Üí Payment ‚Üí Confirm).
2. **Job Application** (Profile ‚Üí Skills ‚Üí Upload CV ‚Üí Review).
3. **Onboarding** (Account Info ‚Üí Preferences ‚Üí Finish).

---

## 5. üìå Mini Challenge

* Th√™m **progress bar** (v√≠ d·ª•: Step 2/3).
* L∆∞u form t·∫°m th·ªùi v√†o **localStorage** ‚Üí user reload kh√¥ng m·∫•t d·ªØ li·ªáu.
* Cho ph√©p **skip step** n·∫øu optional.

---

M·ªü r·ªông sang **Smart Form Component** (Dynamic Form / Config-driven Form) ‚Äì ƒë√¢y l√† b∆∞·ªõc **senior-level** c·ªßa Day 26.


# üß† Smart Form Component (Dynamic / Config-driven)

## 1. üìå V·∫•n ƒë·ªÅ

* Enterprise apps c√≥ **h√†ng ch·ª•c form kh√°c nhau**: login, register, checkout, survey‚Ä¶
* N·∫øu m·ªói form vi·∫øt 1 component ri√™ng ‚Üí **duplicate code** r·∫•t nhi·ªÅu.
* C·∫ßn 1 c√°ch **t√°i s·ª≠ d·ª•ng**: config b·∫±ng JSON/Schema, auto-render form.

üëâ Gi·∫£i ph√°p: **Smart Form Component**

* Input: 1 array `fields` ƒë·ªãnh nghƒ©a form.
* Output: 1 form auto render v·ªõi validation.

---

## 2. üìå Interface ƒë·ªãnh nghƒ©a Field

```ts
type FieldType = "text" | "email" | "password" | "textarea" | "select";

type FieldConfig = {
  name: string;
  label: string;
  type: FieldType;
  placeholder?: string;
  options?: { label: string; value: string }[]; // cho select
  rules?: any; // validation rules cho RHF
};
```

---

## 3. üìå SmartForm.tsx

```tsx
import React from "react";
import { useForm, FormProvider } from "react-hook-form";

type FieldType = "text" | "email" | "password" | "textarea" | "select";

type FieldConfig = {
  name: string;
  label: string;
  type: FieldType;
  placeholder?: string;
  options?: { label: string; value: string }[];
  rules?: any;
};

type SmartFormProps = {
  fields: FieldConfig[];
  onSubmit: (data: any) => void;
};

export default function SmartForm({ fields, onSubmit }: SmartFormProps) {
  const methods = useForm();

  return (
    <FormProvider {...methods}>
      <form onSubmit={methods.handleSubmit(onSubmit)}>
        {fields.map((field) => {
          const { name, label, type, placeholder, options, rules } = field;

          switch (type) {
            case "select":
              return (
                <div key={name}>
                  <label>{label}</label>
                  <select {...methods.register(name, rules)}>
                    <option value="">-- Select --</option>
                    {options?.map((opt) => (
                      <option key={opt.value} value={opt.value}>
                        {opt.label}
                      </option>
                    ))}
                  </select>
                </div>
              );
            case "textarea":
              return (
                <div key={name}>
                  <label>{label}</label>
                  <textarea
                    {...methods.register(name, rules)}
                    placeholder={placeholder}
                  />
                </div>
              );
            default:
              return (
                <div key={name}>
                  <label>{label}</label>
                  <input
                    type={type}
                    {...methods.register(name, rules)}
                    placeholder={placeholder}
                  />
                </div>
              );
          }
        })}

        <button type="submit">Submit</button>
      </form>
    </FormProvider>
  );
}
```

---

## 4. üìå Demo s·ª≠ d·ª•ng

```tsx
import React from "react";
import SmartForm from "./SmartForm";

const fields = [
  { name: "username", label: "Username", type: "text", rules: { required: "Required" } },
  { name: "email", label: "Email", type: "email", rules: { required: "Required" } },
  { name: "password", label: "Password", type: "password", rules: { required: "Required", minLength: 6 } },
  { name: "gender", label: "Gender", type: "select", options: [
      { label: "Male", value: "male" },
      { label: "Female", value: "female" },
    ], rules: { required: "Required" } },
  { name: "bio", label: "Bio", type: "textarea" }
];

export default function RegisterPage() {
  const handleSubmit = (data: any) => {
    console.log("‚úÖ SmartForm Submit:", data);
  };

  return <SmartForm fields={fields} onSubmit={handleSubmit} />;
}
```

---

## 5. üìå Enterprise Use Case

* **Admin Dashboard**: form t·∫°o/s·ª≠a user, product, category‚Ä¶ (d√πng chung 1 SmartForm).
* **Survey/Questionnaire**: load t·ª´ JSON config tr·∫£ v·ªÅ t·ª´ backend.
* **CMS Editor**: backend g·ª≠i schema ‚Üí frontend render form auto.

---

## 6. üìå Challenge

1. Th√™m **validation b·∫±ng Zod** v√†o SmartForm (resolver).
2. T√≠ch h·ª£p v·ªõi **Wizard Form** (SmartForm ch·∫°y t·ª´ng b∆∞·ªõc t·ª´ config).
3. Cho ph√©p backend g·ª≠i config JSON ‚Üí frontend auto render.

---

üëâ ƒê√¢y l√† **foundation cho Form Engine** (r·∫•t nhi·ªÅu h·ªá th·ªëng l·ªõn d√πng).


üìå [<< Ng√†y 25](./Day25.md) | [Ng√†y 27 >>](./Day27.md)

